Algorithms and Data Structure II
Â§5 Shortest Path 
Problems
AY2021, 2Q
https://elms.u-aizu.ac.jp/course/view.php?id=4968
Yuichi Yaguchi, Ph.D (CSE)
Robot Engineering Lab., University of Aizu
Chap. 1
Shortest Path Problem
Â§5 Shortest Path Problems
(Review)
Path and Cycle
â€¢ A path in a graph is a sequence of edges of the form (v1,v2), 
(v2,v3), ..., (vn-1,vn). The path is from v1 to vn of length n-1. 
â€¢ As a special case, a single vertex denotes a path of length 0 from 
itself to itself. 
â€¢ A path is simple if all edges and all vertices on the path, except 
possibly the first and the last vertices, are distinct.
â€¢ A cycle is a simple path of length at least 1 which begins and ends 
at the same vertex. In an undirected graph, a cycle must be of length 
at least 3.
f
b
c
e
d
a
f
b
c
e
d
a
Simple
Cycle
Shortest Path
â€¢ Shortest Path: A path from a node to the other node which 
makes minimum summation of all edge weight. 
â€¢ Let G(V, E) be a weighted graph with non-negative edge distances 
(or costs). 
â€¢ For edge (u,v), the distance of (u,v) is denoted by d(u,v).
â€¢ The distance of a path P, denoted by d(P), is the sum of the 
distances of edges in the path. 
â€¢ For two nodes u and v in G, the shortest path from u to v is the path 
P such that 
ğ‘‘ğ‘ƒ= min ğ‘‘ğ‘„
ğ‘„is a path from ğ‘¢to ğ‘£}
Principle of Optimization
â€¢ Let u â†’v â†’w be a shortest path from u to w. 
Then u â†’v is a shortest path from u to v and v â†’w is a 
shortest path from v to w.
u
v
w
Optimal
Optimal
The other path is not optimal
Types of Shortest path problem
â€¢ Single source shortest path problem and all pairs shortest 
path problem are the most important shortest path problems. 
â€¢ Single source shortest path problem is the problem of finding the 
shortest paths from a specific vertex s, called source, to all other 
vertices of G (connected graph). 
â€¢ All pairs shortest path problem finds the shortest paths between 
every pair of vertices in G (sources are all vertices 
in G). 
Single Path Shortest Path Problem
â€¢ Shortest path spanning tree:
â€¢ Let G(V,E) be a weighted graph with non-negative edge distances, 
and let s be a vertex of G from which every vertex of G can be 
reached. 
â€¢ Then there exists a spanning tree T of G, rooted as s, which contains 
a shortest path from s to every vertex of G. 
f
b
c
e
d
a
12
2
5
7
4
8
7
6
9
3
f
b
c
e
d
a
2
5
6
3
A Weighted Graph G
A Shortest Path Spanning Tree Tâ€™ of G
9
Chapter 1. Quiz
1. Please find a shortest path from node (f) to node (d)
2. Please find a shortest path from (e) to (c)
Chap. 2
Dijkstraâ€™s Algorithm
Â§5 Shortest Path Problems
Single Path Shortest Path Problem
â€¢ Shortest path spanning tree:
â€¢ Let G(V,E) be a weighted graph with non-negative edge distances, 
and let s be a vertex of G from which every vertex of G can be 
reached. 
â€¢ Then there exists a spanning tree T of G, rooted as s, which contains 
a shortest path from s to every vertex of G. 
f
b
c
e
d
a
12
2
5
7
4
8
7
6
9
3
f
b
c
e
d
a
2
5
6
3
A Weighted Graph G
A Shortest Path Spanning Tree Tâ€™ of G
9
Dijkstraâ€™s Algorithm
â€¢ Pseudo code
S = {s}; d[s] = 0;
for (v ïƒV- S) d[v]: = D[s,v];
while (S ï‚¹V) {
Choose a vertex w in V-S such that 
d[w] is a minimum;
add w to S;
for (v ïƒV- S) 
d[v] = min{d[v],d[w]+D[w,v]};
}
â€¢ In the algorithm, graph G(V,E) 
is represented by distance 
matrix D.
â€¢ If the graph is represented by 
an adjacent (distance) matrix, 
the time complexity of 
Dijkstra's algorithm is O(|V|2). 
/* s is the source vertex and S is the partial solution set such that 
the shortest paths from s to each vertex in S lies wholly in S.
For each vertex v ïƒV-S, d[v] contains the distance of current 
shortest path from s to v passing only through vertices of S.*/
Dijkstraâ€™s Algorithm - Example
â€¢ Initially:
S = {v0}, d[v0] = 0,
d[vi] is 2, +ï‚¥,  +ï‚¥, 10
i=1, 2, 3, 4;
â€¢ At the first iteration:
w = v1 is selected, since
d[v1] = 2 is minimum;
â€¢ Then:
d[v2] = min{+ï‚¥, 2+3}=5
d[v4] = min{10, 2+7}=9
Shortest Path Problems
12
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
âˆ
âˆ
âˆ
Dijkstraâ€™s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
âˆ
âˆ
10
1
{v0, v1}
v1
2
2
5
âˆ
9
2
{v0, v1, v2}
v2
5
2
5
âˆ
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
âˆ
âˆ
Dijkstraâ€™s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
âˆ
âˆ
10
1
{v0, v1}
v1
2
2
5
âˆ
9
2
{v0, v1, v2}
v2
5
2
5
âˆ
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
âˆ
âˆ
âˆ
Dijkstraâ€™s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
âˆ
âˆ
10
1
{v0, v1}
v1
2
2
5
âˆ
9
2
{v0, v1, v2}
v2
5
2
5
âˆ
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
âˆ
âˆ
âˆ
Dijkstraâ€™s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
âˆ
âˆ
10
1
{v0, v1}
v1
2
2
5
âˆ
9
2
{v0, v1, v2}
v2
5
2
5
âˆ
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
âˆ
âˆ
âˆ
Dijkstraâ€™s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
âˆ
âˆ
10
1
{v0, v1}
v1
2
2
5
âˆ
9
2
{v0, v1, v2}
v2
5
2
5
âˆ
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
âˆ
âˆ
âˆ
Single Source Shortest Path!
Chapter 2. Quiz
1. Please illustrate to find a shortest path from (f) to (d) using 
Dijkstraâ€™s algorithm 
Itr
S
w
a
b
c
d
e
f
g
Init.
{f}
-
âˆ
3
3
âˆ
1
-
12
Chap. 3
Proof of Dijkstraâ€™s Algorithm
Â§5 Shortest Path Problems
Dijkstraâ€™s Algorithm - Proof
â€¢ We now prove the correctness of Dijkstra's algorithm by induction 
on the size of S. 
â€¢ Basis. 
â€¢ |S| = 1. The shortest path from s to itself has length 0 and a path from s to v, 
wholly within S except for v, consists of the single edge (s,v). Thus, d[v] was 
correctly computed. 
(for ğ‘£âˆˆğ‘‰âˆ’ğ‘†ğ‘‘ğ‘£â‰”ğ·ğ‘ , ğ‘£; )
â€¢ Induction Hypothesis. 
â€¢ Assume the following statements are true for |S| = k ï‚³1: S is the partial 
solution set such that the shortest paths from s to each vertex in S lies 
wholly in S. 
For each vertex v ïƒV- S, d[v] is the distance of current shortest path from s
to v passing only through vertices of S. 
Dijkstraâ€™s Algorithm - Proof
â€¢ Inductive Step
â€¢ For ğ‘†= ğ‘˜, assume ğ‘¤âˆˆğ‘‰âˆ’ğ‘†
such ğ‘‘[ğ‘¤] is a minimum, is 
chosen and added to 
ğ‘†( ğ‘†becomes ğ‘˜+ 1).
â€¢ If ğ‘‘[ğ‘¤] is not the distance of a 
shortest path from s to w, then 
there must be a shorter path P
such that P contains some vertex 
other than w which is not in S. 
â€¢ Let v be the first such vertex on P. 
S
s
w
S
s
w
ğ‘†= ğ‘˜
ğ‘‘[ğ‘¤]
Not Shortest?
Should be exist!
P
Dijkstraâ€™s Algorithm - Proof
â€¢ But then the distance from s to v is 
shorter than d[w], and moreover, the 
shortest path from s to v lies wholly 
within S, except for v itself.
â€¢ Thus, by the inductive hypothesis, 
d[v] < d[w], a contradiction. 
â€¢ We conclude that the path P does not 
exist and d[w] is the distance of the 
shortest path from s to w that lies 
wholly in S. From the update 
operation
ğ‘‘ğ‘£= min ğ‘‘ğ‘£, ğ‘‘ğ‘¤+ ğ·ğ‘¤, ğ‘£
,
we know d[v] are correctly computed.
S
s
v
w
S
s
v
w
Shortest!
The other paths 
are not short
Doubt!
An Efficient Implementation of Dijkstra's
Algorithm 
â€¢ Pseudo code
S = {s}; d[s] = 0;
for (v ïƒV-S) d[v]: = D[s,v];
for (v ïƒV-S) construct d[v] into a
minimum heap;
while (S ï‚¹V) {
delete d[w] from the heap and add w
to S; 
for (v ïƒV-S) if ((w,v) ïƒE){
d[v] = min{d[v],d[w]+D[w,v]};
restore the heap condition;
}
}
â€¢ Dijkstra's algorithm can be made 
more efficiently by maintaining 
the graph using adjacency lists 
and keeping a priority queue of 
the nodes not in S. 
â€¢ Under this implementation, the 
time complexity of Dijkstra's
algorithm is O((|V|+|E|)log|V|). 
/* s is the source vertex and S is the partial solution set such that 
the shortest paths from s to each vertex in S lies wholly in S.
For each vertex v ïƒV-S, d[v] contains the distance of current 
shortest path from s to v passing only through vertices of S.*/
Difference between MST and SPST
â€¢ In Primâ€™s algorithm (Minimum Spanning Tree), vertices and edges 
are added to a tree one by one, each step choosing the shortest 
possible edge from V to V-T to add. 
â€¢ In Dijkstraâ€™s algorithm (Shortest Path Spanning Tree), the edge v
to be added is not the closest, but minimizing d(s,v) + D[w,v].
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
v0
v1
v4
v3
v2
2
3
5
4
v0
v1
v4
v3
v2
2
7
3
4
Minimum Spanning Tree
Shortest Path from v0
Target graph G
Shortest Paths in the Graph with Unit Edge 
Length 
â€¢ Given a graph G(V,E) whose distances of edges are 1. 
â€¢ The shortest path from u to v is the path from u to v with the 
minimum length (the number of edges). 
â€¢ Dijkstra's algorithm may be used to solve this problem. 
However, a simpler algorithm for this problem is BFS 
algorithm. 
25
Shortest Path Problems
Chapter 3. Quiz
1. Please illustrate to find a shortest path from (e) to (c) using 
Dijkstraâ€™s algorithm 
Itr
S
w
a
b
c
d
e
f
g
Init.
{e}
-
5
5
âˆ
8
-
1
4
â€¢ Shortest Path: A path from a node to the other node which 
makes minimum summation of all edge weight. 
â€¢ Dijkstraâ€™s Algorithm:
â€¢ If the graph is represented by an adjacent (distance) matrix, the 
time complexity of Dijkstra's algorithm is O(|V|2). 
â€¢ If the graph using adjacency lists and keeping a priority queue of the 
nodes not in S, the time complexity of Dijkstra's algorithm is 
O((|V|+|E|)log|V|). 
Wrap up todayâ€™s class
Extra Chap.
Longest Path and Flow
Â§5 Shortest path problems
Longest Path ?
The longest path problem is the 
problem of finding a simple path of 
maximum length in a given graph. 
â€¢ From (a) to (g)
â€¢ Shortest: a â†’ g: cost 8
â€¢ Longest: ?
â€¢ LPP is NP-Hard
â€¢ So many â€œEfficient Algorithmâ€ are there 
but still this is NP-Hard (with 
combination explosion)
How many pattern of â€œFlowâ€ are there?
â€¢ From source (s) to terminal (t), if it has 
no-return (no cycle), we can find many 
paths from source to terminal
â€¢ We call â€œFlowâ€ from s to t.
â€¢ s â€“ b â€“ c â€“ t
â€¢ s â€“ b â€“ c â€“ e â€“ t
â€¢ s â€“ b â€“ f â€“ t
â€¢ s â€“ c â€“ t
â€¢ s â€“ c â€“ e â€“ t
â€¢ s â€“ e â€“ t
â€¢ s â€“ f â€“ t 
f
b
c
e
t
s
Definition of Network Flow
â€¢ s-t (source to sink) flow of a graph G = (V,E):
â€¢ For an edge eâˆˆE, Let we think the capacity of edge c(e) and the 
flow of edge f(e)
â€¢ Flow function f(e) is satisfy the following
constraints:
â€¢ 0 â‰¦ f(e) â‰¦ c(e)
â€¢ About v âˆˆ V ï¼¼ {s,t} , 
. (input) Ïƒğ‘’âˆˆğ›¿âˆ’ğ‘£ğ‘“ğ‘’= (output) Ïƒğ‘’âˆˆğ›¿+(ğ‘£) ğ‘“ğ‘’
â€¢ Maximum Flow Condition:
â€¢ max(Ïƒğ‘’âˆˆğ›¿+ ğ‘ ğ‘“ğ‘’) = max(Ïƒğ‘’âˆˆğ›¿âˆ’(ğ‘¡) ğ‘“ğ‘’)
f
b
c
e
t
s
12
3
6
4
2
10
6
6
8
4
How to find Maximum Flow?
â€¢ If we define the capacity of each 
path as left figure:
â€¢ s to b can send â€œ12â€ or less
â€¢ s to c can send â€œ3 + 4â€ or less (in spite 
of s to b can send until 12)
â€¢ s to f can send â€œ6 + 2â€ or less (in spite 
of s to b can send until 12)
â€¢ How to calculate maximum flow 
from s to t ?
f
b
c
e
t
s
12
3
6
4
2
10
6
6
8
4
Ford-Fulkerson
f
b
c
e
t
s
12
3
6
4
2
10
6
6
8
4
Ford-Fulkerson
â¢After
every
step
in
the
algorithm
the
following
is  
maintained:
â‰¤ ğ‘(ğ‘¢, ğ‘£)
â€¢ Capacity Constraints
: âˆ€ğ‘¢, ğ‘£ğœ–ğ¸
ğ‘“ğ‘¢,ğ‘£
â¢
The flow along an edge can not exceed its capacity.
â€¢ Skew Symmetry
: âˆ€ğ‘¢, ğ‘£ğœ–ğ¸
ğ‘“ğ‘¢,ğ‘£= âˆ’ğ‘“(ğ‘£, ğ‘¢)
ich
net flow to a node is zero, except for the source, wh
â¢
The net flow from u to v must be the opposite of the net flow from v to u
â€¢ Flow Conservation :
â¢
Unless u is s or t. The
"produces" flow, and the sink, which "consumes" flow.
Example of Ford-Fulkerson
f
b
c
e
t
s
12/0
3/0
6/0
4/0
2/0
10/0
6/0
6/0
8/0
4/0
f
b
c
e
t
s
12/3
3/3
6/3
4/0
2/0
10/0
6/0
6/0
8/0
4/0
f
b
c
e
t
s
12/3
3/3
6/3
4/0
2/0
10/0
6/0
6/0
8/0
4/0
3
0
9
f
b
c
e
t
s
12/3
3/3
6/6
4/3
2/0
10/0
6/0
6/0
8/0
4/0
0
0
9
1
Example of Ford-Fulkerson
f
b
c
e
t
s
12/3
3/3
6/6
4/3
2/0
10/0
6/6
6/6
8/0
4/0
0
0
9
1
0
0
f
b
c
e
t
s
12/3
3/3
6/6
4/3
2/0
10/0
6/6
6/6
8/4
4/4
0
0
9
1
0
0
0
4
f
b
c
e
t
s
12/3
3/3
6/6
4/4
2/0
10/1
6/6
6/6
8/5
4/4
0
0
9
0
0
0
0
3
9
f
b
c
e
t
s
12/3
3/3
6/6
4/4
2/0
10/1
6/6
6/6
8/5
4/4
s->17
17-> t
Algorithms and Data Structure II
Â§5 Shortest Path 
Problems
AY2021, 2Q
https://elms.u-aizu.ac.jp/course/view.php?id=4968
Yuichi Yaguchi, Ph.D (CSE)
Robot Engineering Lab., University of Aizu
See you next time!
