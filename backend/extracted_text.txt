Algorithms and Data Structure II
§5 Shortest Path 
Problems
AY2021, 2Q
https://elms.u-aizu.ac.jp/course/view.php?id=4968
Yuichi Yaguchi, Ph.D (CSE)
Robot Engineering Lab., University of Aizu
Chap. 1
Shortest Path Problem
§5 Shortest Path Problems
(Review)
Path and Cycle
• A path in a graph is a sequence of edges of the form (v1,v2), 
(v2,v3), ..., (vn-1,vn). The path is from v1 to vn of length n-1. 
• As a special case, a single vertex denotes a path of length 0 from 
itself to itself. 
• A path is simple if all edges and all vertices on the path, except 
possibly the first and the last vertices, are distinct.
• A cycle is a simple path of length at least 1 which begins and ends 
at the same vertex. In an undirected graph, a cycle must be of length 
at least 3.
f
b
c
e
d
a
f
b
c
e
d
a
Simple
Cycle
Shortest Path
• Shortest Path: A path from a node to the other node which 
makes minimum summation of all edge weight. 
• Let G(V, E) be a weighted graph with non-negative edge distances 
(or costs). 
• For edge (u,v), the distance of (u,v) is denoted by d(u,v).
• The distance of a path P, denoted by d(P), is the sum of the 
distances of edges in the path. 
• For two nodes u and v in G, the shortest path from u to v is the path 
P such that 
𝑑𝑃= min 𝑑𝑄
𝑄is a path from 𝑢to 𝑣}
Principle of Optimization
• Let u →v →w be a shortest path from u to w. 
Then u →v is a shortest path from u to v and v →w is a 
shortest path from v to w.
u
v
w
Optimal
Optimal
The other path is not optimal
Types of Shortest path problem
• Single source shortest path problem and all pairs shortest 
path problem are the most important shortest path problems. 
• Single source shortest path problem is the problem of finding the 
shortest paths from a specific vertex s, called source, to all other 
vertices of G (connected graph). 
• All pairs shortest path problem finds the shortest paths between 
every pair of vertices in G (sources are all vertices 
in G). 
Single Path Shortest Path Problem
• Shortest path spanning tree:
• Let G(V,E) be a weighted graph with non-negative edge distances, 
and let s be a vertex of G from which every vertex of G can be 
reached. 
• Then there exists a spanning tree T of G, rooted as s, which contains 
a shortest path from s to every vertex of G. 
f
b
c
e
d
a
12
2
5
7
4
8
7
6
9
3
f
b
c
e
d
a
2
5
6
3
A Weighted Graph G
A Shortest Path Spanning Tree T’ of G
9
Chapter 1. Quiz
1. Please find a shortest path from node (f) to node (d)
2. Please find a shortest path from (e) to (c)
Chap. 2
Dijkstra’s Algorithm
§5 Shortest Path Problems
Single Path Shortest Path Problem
• Shortest path spanning tree:
• Let G(V,E) be a weighted graph with non-negative edge distances, 
and let s be a vertex of G from which every vertex of G can be 
reached. 
• Then there exists a spanning tree T of G, rooted as s, which contains 
a shortest path from s to every vertex of G. 
f
b
c
e
d
a
12
2
5
7
4
8
7
6
9
3
f
b
c
e
d
a
2
5
6
3
A Weighted Graph G
A Shortest Path Spanning Tree T’ of G
9
Dijkstra’s Algorithm
• Pseudo code
S = {s}; d[s] = 0;
for (v V- S) d[v]: = D[s,v];
while (S V) {
Choose a vertex w in V-S such that 
d[w] is a minimum;
add w to S;
for (v V- S) 
d[v] = min{d[v],d[w]+D[w,v]};
}
• In the algorithm, graph G(V,E) 
is represented by distance 
matrix D.
• If the graph is represented by 
an adjacent (distance) matrix, 
the time complexity of 
Dijkstra's algorithm is O(|V|2). 
/* s is the source vertex and S is the partial solution set such that 
the shortest paths from s to each vertex in S lies wholly in S.
For each vertex v V-S, d[v] contains the distance of current 
shortest path from s to v passing only through vertices of S.*/
Dijkstra’s Algorithm - Example
• Initially:
S = {v0}, d[v0] = 0,
d[vi] is 2, +,  +, 10
i=1, 2, 3, 4;
• At the first iteration:
w = v1 is selected, since
d[v1] = 2 is minimum;
• Then:
d[v2] = min{+, 2+3}=5
d[v4] = min{10, 2+7}=9
Shortest Path Problems
12
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
∞
∞
∞
Dijkstra’s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
∞
∞
10
1
{v0, v1}
v1
2
2
5
∞
9
2
{v0, v1, v2}
v2
5
2
5
∞
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
∞
∞
Dijkstra’s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
∞
∞
10
1
{v0, v1}
v1
2
2
5
∞
9
2
{v0, v1, v2}
v2
5
2
5
∞
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
∞
∞
∞
Dijkstra’s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
∞
∞
10
1
{v0, v1}
v1
2
2
5
∞
9
2
{v0, v1, v2}
v2
5
2
5
∞
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
∞
∞
∞
Dijkstra’s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
∞
∞
10
1
{v0, v1}
v1
2
2
5
∞
9
2
{v0, v1, v2}
v2
5
2
5
∞
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
∞
∞
∞
Dijkstra’s Algorithm - Example
Itr
S
w
d[0]
d[1]
d[2]
d[3]
d[4]
Init.
{v0}
-
-
2
∞
∞
10
1
{v0, v1}
v1
2
2
5
∞
9
2
{v0, v1, v2}
v2
5
2
5
∞
9
3
{v0, v1, v2, v3}
v3
9
2
5
9
9
4
{v0, v1, v2, v3, v4}
v4
9
2
5
9
9
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
∞
∞
∞
Single Source Shortest Path!
Chapter 2. Quiz
1. Please illustrate to find a shortest path from (f) to (d) using 
Dijkstra’s algorithm 
Itr
S
w
a
b
c
d
e
f
g
Init.
{f}
-
∞
3
3
∞
1
-
12
Chap. 3
Proof of Dijkstra’s Algorithm
§5 Shortest Path Problems
Dijkstra’s Algorithm - Proof
• We now prove the correctness of Dijkstra's algorithm by induction 
on the size of S. 
• Basis. 
• |S| = 1. The shortest path from s to itself has length 0 and a path from s to v, 
wholly within S except for v, consists of the single edge (s,v). Thus, d[v] was 
correctly computed. 
(for 𝑣∈𝑉−𝑆𝑑𝑣≔𝐷𝑠, 𝑣; )
• Induction Hypothesis. 
• Assume the following statements are true for |S| = k 1: S is the partial 
solution set such that the shortest paths from s to each vertex in S lies 
wholly in S. 
For each vertex v V- S, d[v] is the distance of current shortest path from s
to v passing only through vertices of S. 
Dijkstra’s Algorithm - Proof
• Inductive Step
• For 𝑆= 𝑘, assume 𝑤∈𝑉−𝑆
such 𝑑[𝑤] is a minimum, is 
chosen and added to 
𝑆( 𝑆becomes 𝑘+ 1).
• If 𝑑[𝑤] is not the distance of a 
shortest path from s to w, then 
there must be a shorter path P
such that P contains some vertex 
other than w which is not in S. 
• Let v be the first such vertex on P. 
S
s
w
S
s
w
𝑆= 𝑘
𝑑[𝑤]
Not Shortest?
Should be exist!
P
Dijkstra’s Algorithm - Proof
• But then the distance from s to v is 
shorter than d[w], and moreover, the 
shortest path from s to v lies wholly 
within S, except for v itself.
• Thus, by the inductive hypothesis, 
d[v] < d[w], a contradiction. 
• We conclude that the path P does not 
exist and d[w] is the distance of the 
shortest path from s to w that lies 
wholly in S. From the update 
operation
𝑑𝑣= min 𝑑𝑣, 𝑑𝑤+ 𝐷𝑤, 𝑣
,
we know d[v] are correctly computed.
S
s
v
w
S
s
v
w
Shortest!
The other paths 
are not short
Doubt!
An Efficient Implementation of Dijkstra's
Algorithm 
• Pseudo code
S = {s}; d[s] = 0;
for (v V-S) d[v]: = D[s,v];
for (v V-S) construct d[v] into a
minimum heap;
while (S V) {
delete d[w] from the heap and add w
to S; 
for (v V-S) if ((w,v) E){
d[v] = min{d[v],d[w]+D[w,v]};
restore the heap condition;
}
}
• Dijkstra's algorithm can be made 
more efficiently by maintaining 
the graph using adjacency lists 
and keeping a priority queue of 
the nodes not in S. 
• Under this implementation, the 
time complexity of Dijkstra's
algorithm is O((|V|+|E|)log|V|). 
/* s is the source vertex and S is the partial solution set such that 
the shortest paths from s to each vertex in S lies wholly in S.
For each vertex v V-S, d[v] contains the distance of current 
shortest path from s to v passing only through vertices of S.*/
Difference between MST and SPST
• In Prim’s algorithm (Minimum Spanning Tree), vertices and edges 
are added to a tree one by one, each step choosing the shortest 
possible edge from V to V-T to add. 
• In Dijkstra’s algorithm (Shortest Path Spanning Tree), the edge v
to be added is not the closest, but minimizing d(s,v) + D[w,v].
v0
v1
v4
v3
v2
2
10
7
3
6
5
4
v0
v1
v4
v3
v2
2
3
5
4
v0
v1
v4
v3
v2
2
7
3
4
Minimum Spanning Tree
Shortest Path from v0
Target graph G
Shortest Paths in the Graph with Unit Edge 
Length 
• Given a graph G(V,E) whose distances of edges are 1. 
• The shortest path from u to v is the path from u to v with the 
minimum length (the number of edges). 
• Dijkstra's algorithm may be used to solve this problem. 
However, a simpler algorithm for this problem is BFS 
algorithm. 
25
Shortest Path Problems
Chapter 3. Quiz
1. Please illustrate to find a shortest path from (e) to (c) using 
Dijkstra’s algorithm 
Itr
S
w
a
b
c
d
e
f
g
Init.
{e}
-
5
5
∞
8
-
1
4
• Shortest Path: A path from a node to the other node which 
makes minimum summation of all edge weight. 
• Dijkstra’s Algorithm:
• If the graph is represented by an adjacent (distance) matrix, the 
time complexity of Dijkstra's algorithm is O(|V|2). 
• If the graph using adjacency lists and keeping a priority queue of the 
nodes not in S, the time complexity of Dijkstra's algorithm is 
O((|V|+|E|)log|V|). 
Wrap up today’s class
Extra Chap.
Longest Path and Flow
§5 Shortest path problems
Longest Path ?
The longest path problem is the 
problem of finding a simple path of 
maximum length in a given graph. 
• From (a) to (g)
• Shortest: a → g: cost 8
• Longest: ?
• LPP is NP-Hard
• So many “Efficient Algorithm” are there 
but still this is NP-Hard (with 
combination explosion)
How many pattern of “Flow” are there?
• From source (s) to terminal (t), if it has 
no-return (no cycle), we can find many 
paths from source to terminal
• We call “Flow” from s to t.
• s – b – c – t
• s – b – c – e – t
• s – b – f – t
• s – c – t
• s – c – e – t
• s – e – t
• s – f – t 
f
b
c
e
t
s
Definition of Network Flow
• s-t (source to sink) flow of a graph G = (V,E):
• For an edge e∈E, Let we think the capacity of edge c(e) and the 
flow of edge f(e)
• Flow function f(e) is satisfy the following
constraints:
• 0 ≦ f(e) ≦ c(e)
• About v ∈ V ＼ {s,t} , 
. (input) σ𝑒∈𝛿−𝑣𝑓𝑒= (output) σ𝑒∈𝛿+(𝑣) 𝑓𝑒
• Maximum Flow Condition:
• max(σ𝑒∈𝛿+ 𝑠𝑓𝑒) = max(σ𝑒∈𝛿−(𝑡) 𝑓𝑒)
f
b
c
e
t
s
12
3
6
4
2
10
6
6
8
4
How to find Maximum Flow?
• If we define the capacity of each 
path as left figure:
• s to b can send “12” or less
• s to c can send “3 + 4” or less (in spite 
of s to b can send until 12)
• s to f can send “6 + 2” or less (in spite 
of s to b can send until 12)
• How to calculate maximum flow 
from s to t ?
f
b
c
e
t
s
12
3
6
4
2
10
6
6
8
4
Ford-Fulkerson
f
b
c
e
t
s
12
3
6
4
2
10
6
6
8
4
Ford-Fulkerson
➢After
every
step
in
the
algorithm
the
following
is  
maintained:
≤ 𝑐(𝑢, 𝑣)
• Capacity Constraints
: ∀𝑢, 𝑣𝜖𝐸
𝑓𝑢,𝑣
➢
The flow along an edge can not exceed its capacity.
• Skew Symmetry
: ∀𝑢, 𝑣𝜖𝐸
𝑓𝑢,𝑣= −𝑓(𝑣, 𝑢)
ich
net flow to a node is zero, except for the source, wh
➢
The net flow from u to v must be the opposite of the net flow from v to u
• Flow Conservation :
➢
Unless u is s or t. The
"produces" flow, and the sink, which "consumes" flow.
Example of Ford-Fulkerson
f
b
c
e
t
s
12/0
3/0
6/0
4/0
2/0
10/0
6/0
6/0
8/0
4/0
f
b
c
e
t
s
12/3
3/3
6/3
4/0
2/0
10/0
6/0
6/0
8/0
4/0
f
b
c
e
t
s
12/3
3/3
6/3
4/0
2/0
10/0
6/0
6/0
8/0
4/0
3
0
9
f
b
c
e
t
s
12/3
3/3
6/6
4/3
2/0
10/0
6/0
6/0
8/0
4/0
0
0
9
1
Example of Ford-Fulkerson
f
b
c
e
t
s
12/3
3/3
6/6
4/3
2/0
10/0
6/6
6/6
8/0
4/0
0
0
9
1
0
0
f
b
c
e
t
s
12/3
3/3
6/6
4/3
2/0
10/0
6/6
6/6
8/4
4/4
0
0
9
1
0
0
0
4
f
b
c
e
t
s
12/3
3/3
6/6
4/4
2/0
10/1
6/6
6/6
8/5
4/4
0
0
9
0
0
0
0
3
9
f
b
c
e
t
s
12/3
3/3
6/6
4/4
2/0
10/1
6/6
6/6
8/5
4/4
s->17
17-> t
Algorithms and Data Structure II
§5 Shortest Path 
Problems
AY2021, 2Q
https://elms.u-aizu.ac.jp/course/view.php?id=4968
Yuichi Yaguchi, Ph.D (CSE)
Robot Engineering Lab., University of Aizu
See you next time!
