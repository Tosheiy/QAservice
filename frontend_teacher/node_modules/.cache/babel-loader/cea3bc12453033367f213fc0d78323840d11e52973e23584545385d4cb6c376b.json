{"ast":null,"code":"/*\nCopyright (c) 2020 Daybrush\nname: selecto\nlicense: MIT\nauthor: Daybrush\nrepository: git+https://github.com/daybrush/selecto.git\nversion: 1.26.3\n*/\nimport EventEmitter from '@scena/event-emitter';\nimport Gesto from 'gesto';\nimport { Properties } from 'framework-utils';\nimport { getDocument, hasClass, addClass, calculateBoundSize, getDist, getWindow, isObject, isString, isNode, removeEvent, isFunction, addEvent, isArray, camelize, splitUnit, between } from '@daybrush/utils';\nimport { diff } from '@egjs/children-differ';\nimport DragScroll from '@scena/dragscroll';\nimport KeyController, { getCombi } from 'keycon';\nimport { fitPoints, getOverlapPoints, isInside, getAreaSize } from 'overlap-area';\nimport { createMatrix, getDistElementMatrix, calculateMatrixDist } from 'css-to-mat';\nimport styled from 'css-styled';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n\n/* global Reflect, Promise */\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nfunction getClient(e) {\n  if (\"touches\" in e) {\n    var touch = e.touches[0] || e.changedTouches[0];\n    return {\n      clientX: touch.clientX,\n      clientY: touch.clientY\n    };\n  } else {\n    return {\n      clientX: e.clientX,\n      clientY: e.clientY\n    };\n  }\n}\nfunction filterDuplicated(arr) {\n  if (typeof Map === \"undefined\") {\n    return arr.filter(function (value, index) {\n      return arr.indexOf(value) === index;\n    });\n  }\n  var map = new Map();\n  return arr.filter(function (value) {\n    if (map.has(value)) {\n      return false;\n    }\n    map.set(value, true);\n    return true;\n  });\n}\nfunction elementFromPoint(baseNode, clientX, clientY) {\n  var doc = getDocument(baseNode);\n  return doc.elementFromPoint && doc.elementFromPoint(clientX, clientY) || null;\n}\nfunction createElement(jsx, prevTarget, container) {\n  var tag = jsx.tag,\n    children = jsx.children,\n    attributes = jsx.attributes,\n    className = jsx.className,\n    style = jsx.style;\n  var el = prevTarget || getDocument(container).createElement(tag);\n  for (var name in attributes) {\n    el.setAttribute(name, attributes[name]);\n  }\n  var elChildren = el.children;\n  children.forEach(function (child, i) {\n    createElement(child, elChildren[i], el);\n  });\n  if (className) {\n    className.split(/\\s+/g).forEach(function (name) {\n      if (name && !hasClass(el, name)) {\n        addClass(el, name);\n      }\n    });\n  }\n  if (style) {\n    var elStyle = el.style;\n    for (var name in style) {\n      elStyle[name] = style[name];\n    }\n  }\n  if (!prevTarget && container) {\n    container.appendChild(el);\n  }\n  return el;\n}\nfunction h(tag, attrs) {\n  var children = [];\n  for (var _i = 2; _i < arguments.length; _i++) {\n    children[_i - 2] = arguments[_i];\n  }\n  var _a = attrs || {},\n    _b = _a.className,\n    className = _b === void 0 ? \"\" : _b,\n    _c = _a.style,\n    style = _c === void 0 ? {} : _c,\n    attributes = __rest(_a, [\"className\", \"style\"]);\n  return {\n    tag: tag,\n    className: className,\n    style: style,\n    attributes: attributes,\n    children: children\n  };\n}\nfunction diffValue(prev, cur, func) {\n  if (prev !== cur) {\n    func(prev, cur);\n  }\n}\nfunction getRect(e, ratio, boundArea) {\n  var _a;\n  if (boundArea === void 0) {\n    boundArea = e.data.boundArea;\n  }\n  var _b = e.distX,\n    distX = _b === void 0 ? 0 : _b,\n    _c = e.distY,\n    distY = _c === void 0 ? 0 : _c;\n  var _d = e.data,\n    startX = _d.startX,\n    startY = _d.startY;\n  if (ratio > 0) {\n    var nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));\n    var nextWidth = ratio * nextHeight;\n    distX = (distX >= 0 ? 1 : -1) * nextWidth;\n    distY = (distY >= 0 ? 1 : -1) * nextHeight;\n  }\n  var width = Math.abs(distX);\n  var height = Math.abs(distY);\n  var maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n  var maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n  _a = calculateBoundSize([width, height], [0, 0], [maxWidth, maxHeight], !!ratio), width = _a[0], height = _a[1];\n  distX = (distX >= 0 ? 1 : -1) * width;\n  distY = (distY >= 0 ? 1 : -1) * height;\n  var tx = Math.min(0, distX);\n  var ty = Math.min(0, distY);\n  var left = startX + tx;\n  var top = startY + ty;\n  return {\n    left: left,\n    top: top,\n    right: left + width,\n    bottom: top + height,\n    width: width,\n    height: height\n  };\n}\nfunction getDefaultElementRect(el) {\n  var rect = el.getBoundingClientRect();\n  var left = rect.left,\n    top = rect.top,\n    width = rect.width,\n    height = rect.height;\n  return {\n    pos1: [left, top],\n    pos2: [left + width, top],\n    pos3: [left, top + height],\n    pos4: [left + width, top + height]\n  };\n}\nfunction passTargets(beforeTargets, afterTargets, continueSelectWithoutDeselect) {\n  var _a = diff(beforeTargets, afterTargets),\n    list = _a.list,\n    prevList = _a.prevList,\n    added = _a.added,\n    removed = _a.removed,\n    maintained = _a.maintained;\n  return __spreadArray(__spreadArray(__spreadArray([], added.map(function (index) {\n    return list[index];\n  }), true), removed.map(function (index) {\n    return prevList[index];\n  }), true), continueSelectWithoutDeselect ? maintained.map(function (_a) {\n    var nextIndex = _a[1];\n    return list[nextIndex];\n  }) : [], true);\n}\nfunction getLineSize(points) {\n  var size = 0;\n  var length = points.length;\n  for (var i = 1; i < length; ++i) {\n    size = Math.max(getDist(points[i], points[i - 1]), size);\n  }\n  return size;\n}\nvar injector = styled(\"\\n:host {\\n    position: fixed;\\n    display: none;\\n    border: 1px solid #4af;\\n    background: rgba(68, 170, 255, 0.5);\\n    pointer-events: none;\\n    will-change: transform;\\n    z-index: 100;\\n}\\n\");\n/**\n * @memberof Selecto\n */\n\nvar CLASS_NAME = \"selecto-selection \".concat(injector.className);\nvar PROPERTIES = [\"className\", \"boundContainer\", \"selectableTargets\", \"selectByClick\", \"selectFromInside\", \"continueSelect\", \"continueSelectWithoutDeselect\", \"toggleContinueSelect\", \"toggleContinueSelectWithoutDeselect\", \"keyContainer\", \"hitRate\", \"scrollOptions\", \"checkInput\", \"preventDefault\", \"ratio\", \"getElementRect\", \"preventDragFromInside\", \"rootContainer\", \"dragCondition\", \"clickBySelectEnd\", \"checkOverflow\", \"innerScrollOptions\"];\n/**\n * @memberof Selecto\n */\n\nvar OPTIONS = __spreadArray([\n// ignore target, container,\n\"dragContainer\", \"cspNonce\", \"preventClickEventOnDrag\", \"preventClickEventOnDragStart\", \"preventRightClick\"], PROPERTIES, true);\nvar OPTION_TYPES = {\n  className: String,\n  boundContainer: null,\n  portalContainer: null,\n  container: null,\n  dragContainer: null,\n  selectableTargets: Array,\n  selectByClick: Boolean,\n  selectFromInside: Boolean,\n  continueSelect: Boolean,\n  toggleContinueSelect: Array,\n  toggleContinueSelectWithoutDeselect: Array,\n  keyContainer: null,\n  hitRate: Number,\n  scrollOptions: Object,\n  checkInput: Boolean,\n  preventDefault: Boolean,\n  cspNonce: String,\n  ratio: Number,\n  getElementRect: Function,\n  preventDragFromInside: Boolean,\n  rootContainer: Object,\n  dragCondition: Function,\n  clickBySelectEnd: Boolean,\n  continueSelectWithoutDeselect: Boolean,\n  preventClickEventOnDragStart: Boolean,\n  preventClickEventOnDrag: Boolean,\n  checkOverflow: Boolean,\n  innerScrollOptions: Object\n};\n/**\n * @memberof Selecto\n */\n\nvar EVENTS = [\"dragStart\", \"drag\", \"dragEnd\", \"selectStart\", \"select\", \"selectEnd\", \"keydown\", \"keyup\", \"scroll\", \"innerScroll\"];\n/**\n * @memberof Selecto\n */\n\nvar METHODS = [\"clickTarget\", \"getSelectableElements\", \"setSelectedTargets\", \"getElementPoints\", \"getSelectedTargets\", \"findSelectableTargets\", \"triggerDragStart\", \"checkScroll\", \"selectTargetsByPoints\", \"setSelectedTargetsByPoints\"];\n\n/**\n * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.\n * @sort 1\n * @extends EventEmitter\n */\n\nvar Selecto = /*#__PURE__*/\nfunction (_super) {\n  __extends(Selecto, _super);\n  /**\n   *\n   */\n\n  function Selecto(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _this = _super.call(this) || this;\n    _this.selectedTargets = [];\n    _this.dragScroll = new DragScroll();\n    _this._onDragStart = function (e, clickedTarget) {\n      var data = e.data,\n        clientX = e.clientX,\n        clientY = e.clientY,\n        inputEvent = e.inputEvent;\n      var _a = _this.options,\n        selectFromInside = _a.selectFromInside,\n        selectByClick = _a.selectByClick,\n        rootContainer = _a.rootContainer,\n        boundContainer = _a.boundContainer,\n        _b = _a.preventDragFromInside,\n        preventDragFromInside = _b === void 0 ? true : _b,\n        clickBySelectEnd = _a.clickBySelectEnd,\n        dragCondition = _a.dragCondition;\n      if (dragCondition && !dragCondition(e)) {\n        e.stop();\n        return;\n      }\n      data.data = {};\n      var win = getWindow(_this.container);\n      data.innerWidth = win.innerWidth;\n      data.innerHeight = win.innerHeight;\n      _this.findSelectableTargets(data);\n      data.startSelectedTargets = _this.selectedTargets;\n      data.scaleMatrix = createMatrix();\n      data.containerX = 0;\n      data.containerY = 0;\n      var container = _this.container;\n      var boundArea = {\n        left: -Infinity,\n        top: -Infinity,\n        right: Infinity,\n        bottom: Infinity\n      };\n      if (rootContainer) {\n        var containerRect = _this.container.getBoundingClientRect();\n        data.containerX = containerRect.left;\n        data.containerY = containerRect.top;\n        data.scaleMatrix = getDistElementMatrix(_this.container, rootContainer);\n      }\n      if (boundContainer) {\n        var boundInfo = isObject(boundContainer) && \"element\" in boundContainer ? __assign({\n          left: true,\n          top: true,\n          bottom: true,\n          right: true\n        }, boundContainer) : {\n          element: boundContainer,\n          left: true,\n          top: true,\n          bottom: true,\n          right: true\n        };\n        var boundElement = boundInfo.element;\n        var rectElement = void 0;\n        if (boundElement) {\n          if (isString(boundElement)) {\n            rectElement = getDocument(container).querySelector(boundElement);\n          } else if (boundElement === true) {\n            rectElement = _this.container;\n          } else {\n            rectElement = boundElement;\n          }\n          var rect = rectElement.getBoundingClientRect();\n          if (boundInfo.left) {\n            boundArea.left = rect.left;\n          }\n          if (boundInfo.top) {\n            boundArea.top = rect.top;\n          }\n          if (boundInfo.right) {\n            boundArea.right = rect.right;\n          }\n          if (boundInfo.bottom) {\n            boundArea.bottom = rect.bottom;\n          }\n        }\n      }\n      data.boundArea = boundArea;\n      var hitRect = {\n        left: clientX,\n        top: clientY,\n        right: clientX,\n        bottom: clientY,\n        width: 0,\n        height: 0\n      };\n      var firstPassedTargets = []; // allow click on select\n\n      var allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n      var hasInsideTargets = false;\n      if (!selectFromInside || allowClickBySelectEnd) {\n        var pointTarget = _this._findElement(clickedTarget || inputEvent.target,\n        // elementFromPoint(clientX, clientY),\n        data.selectableTargets);\n        hasInsideTargets = !!pointTarget;\n        if (allowClickBySelectEnd) {\n          firstPassedTargets = pointTarget ? [pointTarget] : [];\n        }\n      }\n      var isPreventSelect = !selectFromInside && hasInsideTargets; // prevent drag from inside when selectByClick is false\n\n      if (isPreventSelect && !selectByClick) {\n        e.stop();\n        return false;\n      }\n      var type = inputEvent.type;\n      var isTrusted = type === \"mousedown\" || type === \"touchstart\";\n      /**\n       * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n       * Call the stop () function if you have a specific element or don't want to raise a select\n       * @memberof Selecto\n       * @event dragStart\n       * @param {OnDragStart} - Parameters for the dragStart event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"dragStart\", e => {\n       *   if (e.inputEvent.target.tagName === \"SPAN\") {\n       *     e.stop();\n       *   }\n       * }).on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n\n      var result = !e.isClick && isTrusted ? _this.emit(\"dragStart\", __assign(__assign({}, e), {\n        data: data.data\n      })) : true;\n      if (!result) {\n        e.stop();\n        return false;\n      }\n      if (_this.continueSelect) {\n        firstPassedTargets = passTargets(_this.selectedTargets, firstPassedTargets, _this.continueSelectWithoutDeselect);\n        data.startPassedTargets = _this.selectedTargets;\n      } else {\n        data.startPassedTargets = [];\n      }\n      _this._select(firstPassedTargets, hitRect, e, true, isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside);\n      data.startX = clientX;\n      data.startY = clientY;\n      data.selectFlag = false;\n      data.preventDragFromInside = false;\n      if (inputEvent.target) {\n        var offsetPos = calculateMatrixDist(data.scaleMatrix, [clientX - data.containerX, clientY - data.containerY]);\n        _this.target.style.cssText += \"position: \".concat(rootContainer ? \"absolute\" : \"fixed\", \";\") + \"left:0px;top:0px;\" + \"transform: translate(\".concat(offsetPos[0], \"px, \").concat(offsetPos[1], \"px)\");\n      }\n      if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n        inputEvent.preventDefault(); // prevent drag from inside when selectByClick is true and force call `selectEnd`\n\n        if (preventDragFromInside) {\n          _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, hitRect, e, true);\n          data.preventDragFromInside = true;\n        }\n      } else {\n        data.selectFlag = true; // why?\n        // if (type === \"touchstart\") {\n        //     inputEvent.preventDefault();\n        // }\n\n        var _c = _this.options,\n          scrollOptions = _c.scrollOptions,\n          innerScrollOptions = _c.innerScrollOptions;\n        var isInnerScroll = false;\n        if (innerScrollOptions) {\n          var inputEvent_1 = e.inputEvent;\n          var target = inputEvent_1.target;\n          var innerScrollElement = null;\n          var parentElement = target;\n          while (parentElement && parentElement !== getDocument(container).body) {\n            var overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n            if (overflow) {\n              innerScrollElement = parentElement;\n              break;\n            }\n            parentElement = parentElement.parentElement;\n          }\n          if (innerScrollElement) {\n            data.innerScrollOptions = __assign({\n              container: innerScrollElement,\n              checkScrollEvent: true\n            }, innerScrollOptions === true ? {} : innerScrollOptions);\n            _this.dragScroll.dragStart(e, data.innerScrollOptions);\n            isInnerScroll = true;\n          }\n        }\n        if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n          _this.dragScroll.dragStart(e, scrollOptions);\n        }\n        if (isPreventSelect && selectByClick && clickBySelectEnd) {\n          data.selectFlag = false;\n          e.preventDrag();\n        }\n      }\n      return true;\n    };\n    _this._onDrag = function (e) {\n      if (e.data.selectFlag) {\n        var scrollOptions = _this.scrollOptions;\n        var innerScrollOptions = e.data.innerScrollOptions;\n        var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container); // If it is a scrolling position, pass drag\n\n        if (hasScrollOptions && !e.isScroll && _this.dragScroll.drag(e, innerScrollOptions || scrollOptions)) {\n          return;\n        }\n      }\n      _this._checkSelected(e);\n    };\n    _this._onDragEnd = function (e) {\n      var data = e.data,\n        inputEvent = e.inputEvent;\n      var rect = getRect(e, _this.options.ratio);\n      var selectFlag = data.selectFlag;\n      var container = _this.container;\n      /**\n       * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n       * @memberof Selecto\n       * @event dragEnd\n       * @param {OnDragEnd} - Parameters for the dragEnd event\n       */\n\n      if (inputEvent) {\n        _this.emit(\"dragEnd\", __assign(__assign({\n          isDouble: !!e.isDouble,\n          isClick: !!e.isClick,\n          isDrag: false,\n          isSelect: selectFlag\n        }, e), {\n          data: data.data,\n          rect: rect\n        }));\n      }\n      _this.target.style.cssText += \"display: none;\";\n      if (selectFlag) {\n        data.selectFlag = false;\n        _this.dragScroll.dragEnd();\n      } else if (_this.selectByClick && _this.clickBySelectEnd) {\n        // only clickBySelectEnd\n        var pointTarget = _this._findElement((inputEvent === null || inputEvent === void 0 ? void 0 : inputEvent.target) || elementFromPoint(container, e.clientX, e.clientY), data.selectableTargets);\n        _this._select(pointTarget ? [pointTarget] : [], rect, e);\n      }\n      if (!data.preventDragFromInside) {\n        _this._selectEnd(data.startSelectedTargets, data.startPassedTargets, rect, e);\n      }\n    };\n    _this._onKeyDown = function (e) {\n      var options = _this.options;\n      var isKeyDown = false;\n      if (!_this._keydownContinueSelect) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelect);\n        _this._keydownContinueSelect = result;\n        isKeyDown || (isKeyDown = result);\n      }\n      if (!_this._keydownContinueSelectWithoutDeselection) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect);\n        _this._keydownContinueSelectWithoutDeselection = result;\n        isKeyDown || (isKeyDown = result);\n      }\n      if (!isKeyDown) {\n        return;\n      }\n      /**\n       * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.\n       * @memberof Selecto\n       * @event keydown\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   toggleContinueSelect: \"shift\";\n       *   keyContainer: window,\n       * });\n       *\n       * selecto.on(\"keydown\", () => {\n       *   document.querySelector(\".button\").classList.add(\"selected\");\n       * }).on(\"keyup\", () => {\n       *   document.querySelector(\".button\").classList.remove(\"selected\");\n       * }).on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n\n      _this.emit(\"keydown\", {\n        keydownContinueSelect: _this._keydownContinueSelect,\n        keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection\n      });\n    };\n    _this._onKeyUp = function (e) {\n      var options = _this.options;\n      var isKeyUp = false;\n      if (_this._keydownContinueSelect) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelect, true);\n        _this._keydownContinueSelect = !result;\n        isKeyUp || (isKeyUp = result);\n      }\n      if (_this._keydownContinueSelectWithoutDeselection) {\n        var result = _this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect, true);\n        _this._keydownContinueSelectWithoutDeselection = !result;\n        isKeyUp || (isKeyUp = result);\n      }\n      if (!isKeyUp) {\n        return;\n      }\n      /**\n       * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.\n       * @memberof Selecto\n       * @event keyup\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   toggleContinueSelect: \"shift\";\n       *   keyContainer: window,\n       * });\n       *\n       * selecto.on(\"keydown\", () => {\n       *   document.querySelector(\".button\").classList.add(\"selected\");\n       * }).on(\"keyup\", () => {\n       *   document.querySelector(\".button\").classList.remove(\"selected\");\n       * }).on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n\n      _this.emit(\"keyup\", {\n        keydownContinueSelect: _this._keydownContinueSelect,\n        keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection\n      });\n    };\n    _this._onBlur = function () {\n      if (_this._keydownContinueSelect || _this._keydownContinueSelectWithoutDeselection) {\n        _this._keydownContinueSelect = false;\n        _this._keydownContinueSelectWithoutDeselection = false;\n        _this.emit(\"keyup\", {\n          keydownContinueSelect: _this._keydownContinueSelect,\n          keydownContinueSelectWithoutDeselection: _this._keydownContinueSelectWithoutDeselection\n        });\n      }\n    };\n    _this._onDocumentSelectStart = function (e) {\n      var doc = getDocument(_this.container);\n      if (!_this.gesto.isFlag()) {\n        return;\n      }\n      var dragContainer = _this.dragContainer;\n      if (dragContainer === getWindow(_this.container)) {\n        dragContainer = doc.documentElement;\n      }\n      var containers = isNode(dragContainer) ? [dragContainer] : [].slice.call(dragContainer);\n      var target = e.target;\n      containers.some(function (container) {\n        if (container === target || container.contains(target)) {\n          e.preventDefault();\n          return true;\n        }\n      });\n    };\n    _this.target = options.portalContainer;\n    var container = options.container;\n    _this.options = __assign({\n      className: \"\",\n      portalContainer: null,\n      container: null,\n      dragContainer: null,\n      selectableTargets: [],\n      selectByClick: true,\n      selectFromInside: true,\n      clickBySelectEnd: false,\n      hitRate: 100,\n      continueSelect: false,\n      continueSelectWithoutDeselect: false,\n      toggleContinueSelect: null,\n      toggleContinueSelectWithoutDeselect: null,\n      keyContainer: null,\n      scrollOptions: null,\n      checkInput: false,\n      preventDefault: false,\n      boundContainer: false,\n      preventDragFromInside: true,\n      dragCondition: null,\n      rootContainer: null,\n      checkOverflow: false,\n      innerScrollOptions: false,\n      getElementRect: getDefaultElementRect,\n      cspNonce: \"\",\n      ratio: 0\n    }, options);\n    var portalContainer = _this.options.portalContainer;\n    if (portalContainer) {\n      container = portalContainer.parentElement;\n    }\n    _this.container = container || document.body;\n    _this.initElement();\n    _this.initDragScroll();\n    _this.setKeyController();\n    return _this;\n  }\n  /**\n   * You can set the currently selected targets.\n   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n   */\n\n  var __proto = Selecto.prototype;\n  __proto.setSelectedTargets = function (selectedTargets) {\n    var beforeSelected = this.selectedTargets;\n    var _a = diff(beforeSelected, selectedTargets),\n      added = _a.added,\n      removed = _a.removed,\n      prevList = _a.prevList,\n      list = _a.list;\n    this.selectedTargets = selectedTargets;\n    return {\n      added: added.map(function (index) {\n        return list[index];\n      }),\n      removed: removed.map(function (index) {\n        return prevList[index];\n      }),\n      beforeSelected: beforeSelected,\n      selected: selectedTargets\n    };\n  };\n  /**\n   * You can set the currently selected targets by points\n   * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n   */\n\n  __proto.setSelectedTargetsByPoints = function (point1, point2) {\n    var left = Math.min(point1[0], point2[0]);\n    var top = Math.min(point1[1], point2[1]);\n    var right = Math.max(point1[0], point2[0]);\n    var bottom = Math.max(point1[1], point2[1]);\n    var rect = {\n      left: left,\n      top: top,\n      right: right,\n      bottom: bottom,\n      width: right - left,\n      height: bottom - top\n    };\n    var data = {\n      ignoreClick: true\n    };\n    this.findSelectableTargets(data);\n    var selectedElements = this.hitTest(rect, data, true, null);\n    var result = this.setSelectedTargets(selectedElements);\n    return __assign(__assign({}, result), {\n      rect: rect\n    });\n  };\n  /**\n   * Select target by virtual drag from startPoint to endPoint.\n   * The target of inputEvent is null.\n   */\n\n  __proto.selectTargetsByPoints = function (startPoint, endPoint) {\n    var mousedown = new MouseEvent(\"mousedown\", {\n      clientX: startPoint[0],\n      clientY: startPoint[1],\n      cancelable: true,\n      bubbles: true\n    });\n    var mousemove = new MouseEvent(\"mousemove\", {\n      clientX: endPoint[0],\n      clientY: endPoint[1],\n      cancelable: true,\n      bubbles: true\n    });\n    var mouseup = new MouseEvent(\"mousemove\", {\n      clientX: endPoint[0],\n      clientY: endPoint[1],\n      cancelable: true,\n      bubbles: true\n    });\n    var gesto = this.gesto;\n    var result = gesto.onDragStart(mousedown);\n    if (result !== false) {\n      gesto.onDrag(mousemove);\n      gesto.onDragEnd(mouseup);\n    }\n  };\n  /**\n   * You can get the currently selected targets.\n   */\n\n  __proto.getSelectedTargets = function () {\n    return this.selectedTargets;\n  };\n  /**\n   * `OnDragStart` is triggered by an external event.\n   * @param - external event\n   * @example\n   * import Selecto from \"selecto\";\n   *\n   * const selecto = new Selecto();\n   *\n   * window.addEventListener(\"mousedown\", e => {\n   *   selecto.triggerDragStart(e);\n   * });\n   */\n\n  __proto.triggerDragStart = function (e) {\n    this.gesto.triggerDragStart(e);\n    return this;\n  };\n  /**\n   * Destroy elements, properties, and events.\n   */\n\n  __proto.destroy = function () {\n    var _a;\n    this.off();\n    this.keycon && this.keycon.destroy();\n    this.gesto.unset();\n    this.injectResult.destroy();\n    this.dragScroll.dragEnd();\n    removeEvent(document, \"selectstart\", this._onDocumentSelectStart);\n    if (!this.options.portalContainer) {\n      (_a = this.target.parentElement) === null || _a === void 0 ? void 0 : _a.removeChild(this.target);\n    }\n    this.keycon = null;\n    this.gesto = null;\n    this.injectResult = null;\n    this.target = null;\n    this.container = null;\n    this.options = null;\n  };\n  __proto.getElementPoints = function (target) {\n    var getElementRect = this.getElementRect || getDefaultElementRect;\n    var info = getElementRect(target);\n    var points = [info.pos1, info.pos2, info.pos4, info.pos3];\n    if (getElementRect !== getDefaultElementRect) {\n      var rect = target.getBoundingClientRect();\n      return fitPoints(points, rect);\n    }\n    return points;\n  };\n  /**\n   * Get all elements set in `selectableTargets`.\n   */\n\n  __proto.getSelectableElements = function () {\n    var container = this.container;\n    var selectableElements = [];\n    this.options.selectableTargets.forEach(function (target) {\n      if (isFunction(target)) {\n        var result = target();\n        if (result) {\n          selectableElements.push.apply(selectableElements, [].slice.call(result));\n        }\n      } else if (isNode(target)) {\n        selectableElements.push(target);\n      } else if (isObject(target)) {\n        selectableElements.push(target.value || target.current);\n      } else {\n        var elements = [].slice.call(getDocument(container).querySelectorAll(target));\n        selectableElements.push.apply(selectableElements, elements);\n      }\n    });\n    return selectableElements;\n  };\n  /**\n   * If scroll occurs during dragging, you can manually call this method to check the position again.\n   */\n\n  __proto.checkScroll = function () {\n    if (!this.gesto.isFlag()) {\n      return;\n    }\n    var scrollOptions = this.scrollOptions;\n    var innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n    var hasScrollOptions = innerScrollOptions || (scrollOptions === null || scrollOptions === void 0 ? void 0 : scrollOptions.container); // If it is a scrolling position, pass drag\n\n    if (hasScrollOptions) {\n      this.dragScroll.checkScroll(__assign({\n        inputEvent: this.gesto.getCurrentEvent()\n      }, innerScrollOptions || scrollOptions));\n    }\n  };\n  /**\n   * Find for selectableTargets again during drag event\n   * You can update selectable targets during an event.\n   */\n\n  __proto.findSelectableTargets = function (data) {\n    var _this = this;\n    if (data === void 0) {\n      data = this.gesto.getEventData();\n    }\n    var selectableTargets = this.getSelectableElements();\n    var selectablePoints = selectableTargets.map(function (target) {\n      return _this.getElementPoints(target);\n    });\n    data.selectableTargets = selectableTargets;\n    data.selectablePoints = selectablePoints;\n    data.selectableParentMap = null;\n    var options = this.options;\n    var hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n    var doc = getDocument(this.container);\n    if (hasIndexesMap) {\n      var parentMap_1 = new Map();\n      data.selectableInnerScrollParentMap = parentMap_1;\n      data.selectableInnerScrollPathsList = selectableTargets.map(function (target, index) {\n        var parentElement = target.parentElement;\n        var parents = [];\n        var paths = [];\n        var _loop_1 = function () {\n          var info = parentMap_1.get(parentElement);\n          if (!info) {\n            var overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n            if (overflow) {\n              var rect = getDefaultElementRect(parentElement);\n              info = {\n                parentElement: parentElement,\n                indexes: [],\n                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                paths: __spreadArray([], paths, true)\n              };\n              parents.push(parentElement);\n              parents.forEach(function (prevParentElement) {\n                parentMap_1.set(prevParentElement, info);\n              });\n              parents = [];\n            }\n          }\n          if (info) {\n            parentElement = info.parentElement;\n            parentMap_1.get(parentElement).indexes.push(index);\n            paths.push(parentElement);\n          } else {\n            parents.push(parentElement);\n          }\n          parentElement = parentElement.parentElement;\n        };\n        while (parentElement && parentElement !== doc.body) {\n          _loop_1();\n        }\n        return paths;\n      });\n    }\n    if (!options.checkOverflow) {\n      data.selectableInners = selectableTargets.map(function () {\n        return true;\n      });\n    }\n    this._refreshGroups(data);\n    return selectableTargets;\n  };\n  /**\n   * External click or mouse events can be applied to the selecto.\n   * @params - Extenal click or mouse event\n   * @params - Specify the clicked target directly.\n   */\n\n  __proto.clickTarget = function (e, clickedTarget) {\n    var _a = getClient(e),\n      clientX = _a.clientX,\n      clientY = _a.clientY;\n    var dragEvent = {\n      data: {\n        selectFlag: false\n      },\n      clientX: clientX,\n      clientY: clientY,\n      inputEvent: e,\n      isClick: true,\n      isTrusted: false,\n      stop: function () {\n        return false;\n      }\n    };\n    if (this._onDragStart(dragEvent, clickedTarget)) {\n      this._onDragEnd(dragEvent);\n    }\n    return this;\n  };\n  __proto.setKeyController = function () {\n    var _a = this.options,\n      keyContainer = _a.keyContainer,\n      toggleContinueSelect = _a.toggleContinueSelect,\n      toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n    if (this.keycon) {\n      this.keycon.destroy();\n      this.keycon = null;\n    }\n    if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {\n      this.keycon = new KeyController(keyContainer || getWindow(this.container));\n      this.keycon.keydown(this._onKeyDown).keyup(this._onKeyUp).on(\"blur\", this._onBlur);\n    }\n  };\n  __proto.setClassName = function (nextClassName) {\n    this.options.className = nextClassName;\n    this.target.setAttribute(\"class\", \"\".concat(CLASS_NAME, \" \").concat(nextClassName || \"\"));\n  };\n  __proto.setKeyEvent = function () {\n    var _a = this.options,\n      toggleContinueSelect = _a.toggleContinueSelect,\n      toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n    if (!toggleContinueSelect && !toggleContinueSelectWithoutDeselect || this.keycon) {\n      return;\n    }\n    this.setKeyController();\n  }; // with getter, setter property\n\n  __proto.setKeyContainer = function (keyContainer) {\n    var _this = this;\n    var options = this.options;\n    diffValue(options.keyContainer, keyContainer, function () {\n      options.keyContainer = keyContainer;\n      _this.setKeyController();\n    });\n  };\n  __proto.getContinueSelect = function () {\n    var _a = this.options,\n      continueSelect = _a.continueSelect,\n      toggleContinueSelect = _a.toggleContinueSelect;\n    if (!toggleContinueSelect || !this._keydownContinueSelect) {\n      return continueSelect;\n    }\n    return !continueSelect;\n  };\n  __proto.getContinueSelectWithoutDeselect = function () {\n    var _a = this.options,\n      continueSelectWithoutDeselect = _a.continueSelectWithoutDeselect,\n      toggleContinueSelectWithoutDeselect = _a.toggleContinueSelectWithoutDeselect;\n    if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {\n      return continueSelectWithoutDeselect;\n    }\n    return !continueSelectWithoutDeselect;\n  };\n  __proto.setToggleContinueSelect = function (toggleContinueSelect) {\n    var _this = this;\n    var options = this.options;\n    diffValue(options.toggleContinueSelect, toggleContinueSelect, function () {\n      options.toggleContinueSelect = toggleContinueSelect;\n      _this.setKeyEvent();\n    });\n  };\n  __proto.setToggleContinueSelectWithoutDeselect = function (toggleContinueSelectWithoutDeselect) {\n    var _this = this;\n    var options = this.options;\n    diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, function () {\n      options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;\n      _this.setKeyEvent();\n    });\n  };\n  __proto.setPreventDefault = function (value) {\n    this.gesto.options.preventDefault = value;\n  };\n  __proto.setCheckInput = function (value) {\n    this.gesto.options.checkInput = value;\n  };\n  __proto.initElement = function () {\n    var _a = this.options,\n      dragContainer = _a.dragContainer,\n      checkInput = _a.checkInput,\n      preventDefault = _a.preventDefault,\n      preventClickEventOnDragStart = _a.preventClickEventOnDragStart,\n      preventClickEventOnDrag = _a.preventClickEventOnDrag,\n      preventClickEventByCondition = _a.preventClickEventByCondition,\n      _b = _a.preventRightClick,\n      preventRightClick = _b === void 0 ? true : _b,\n      className = _a.className;\n    var container = this.container;\n    this.target = createElement(h(\"div\", {\n      className: \"\".concat(CLASS_NAME, \" \").concat(className || \"\")\n    }), this.target, container);\n    var target = this.target;\n    this.dragContainer = typeof dragContainer === \"string\" ? [].slice.call(getDocument(container).querySelectorAll(dragContainer)) : dragContainer || this.target.parentNode;\n    this.gesto = new Gesto(this.dragContainer, {\n      checkWindowBlur: true,\n      container: getWindow(container),\n      checkInput: checkInput,\n      preventDefault: preventDefault,\n      preventClickEventOnDragStart: preventClickEventOnDragStart,\n      preventClickEventOnDrag: preventClickEventOnDrag,\n      preventClickEventByCondition: preventClickEventByCondition,\n      preventRightClick: preventRightClick\n    }).on({\n      dragStart: this._onDragStart,\n      drag: this._onDrag,\n      dragEnd: this._onDragEnd\n    });\n    addEvent(document, \"selectstart\", this._onDocumentSelectStart);\n    this.injectResult = injector.inject(target, {\n      nonce: this.options.cspNonce\n    });\n  };\n  __proto.hitTest = function (selectRect, data, isDrag, gestoEvent) {\n    var _a = this.options,\n      hitRate = _a.hitRate,\n      selectByClick = _a.selectByClick;\n    var left = selectRect.left,\n      top = selectRect.top,\n      right = selectRect.right,\n      bottom = selectRect.bottom;\n    var innerGroups = data.innerGroups;\n    var innerWidth = data.innerWidth;\n    var innerHeight = data.innerHeight;\n    var clientX = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientX;\n    var clientY = gestoEvent === null || gestoEvent === void 0 ? void 0 : gestoEvent.clientY;\n    var ignoreClick = data.ignoreClick;\n    var rectPoints = [[left, top], [right, top], [right, bottom], [left, bottom]];\n    var isHit = function (points, el) {\n      var hitRateValue = typeof hitRate === \"function\" ? splitUnit(\"\".concat(hitRate(el))) : splitUnit(\"\".concat(hitRate));\n      var inArea = ignoreClick ? false : isInside([clientX, clientY], points);\n      if (!isDrag && selectByClick && inArea) {\n        return true;\n      }\n      var overlapPoints = getOverlapPoints(rectPoints, points);\n      if (!overlapPoints.length) {\n        return false;\n      }\n      var overlapSize = getAreaSize(overlapPoints); // Line\n\n      var targetSize = 0;\n      if (overlapSize === 0 && getAreaSize(points) === 0) {\n        targetSize = getLineSize(points);\n        overlapSize = getLineSize(overlapPoints);\n      } else {\n        targetSize = getAreaSize(points);\n      }\n      if (hitRateValue.unit === \"px\") {\n        return overlapSize >= hitRateValue.value;\n      } else {\n        var rate = between(Math.round(overlapSize / targetSize * 100), 0, 100);\n        return rate >= Math.min(100, hitRateValue.value);\n      }\n    };\n    var selectableTargets = data.selectableTargets;\n    var selectablePoints = data.selectablePoints;\n    var selectableInners = data.selectableInners;\n    if (!innerGroups) {\n      return selectableTargets.filter(function (_, i) {\n        if (!selectableInners[i]) {\n          return false;\n        }\n        return isHit(selectablePoints[i], selectableTargets[i]);\n      });\n    }\n    var selectedTargets = [];\n    var minX = Math.floor(left / innerWidth);\n    var maxX = Math.floor(right / innerWidth);\n    var minY = Math.floor(top / innerHeight);\n    var maxY = Math.floor(bottom / innerHeight);\n    for (var x = minX; x <= maxX; ++x) {\n      var yGroups = innerGroups[x];\n      if (!yGroups) {\n        continue;\n      }\n      for (var y = minY; y <= maxY; ++y) {\n        var group = yGroups[y];\n        if (!group) {\n          continue;\n        }\n        group.forEach(function (index) {\n          var points = selectablePoints[index];\n          var inner = selectableInners[index];\n          var target = selectableTargets[index];\n          if (inner && isHit(points, target)) {\n            selectedTargets.push(target);\n          }\n        });\n      }\n    }\n    return filterDuplicated(selectedTargets);\n  };\n  __proto.initDragScroll = function () {\n    var _this = this;\n    this.dragScroll.on(\"scrollDrag\", function (_a) {\n      var next = _a.next;\n      next(_this.gesto.getCurrentEvent());\n    }).on(\"scroll\", function (_a) {\n      var container = _a.container,\n        direction = _a.direction;\n      var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;\n      if (innerScrollOptions) {\n        _this.emit(\"innerScroll\", {\n          container: container,\n          direction: direction\n        });\n      } else {\n        _this.emit(\"scroll\", {\n          container: container,\n          direction: direction\n        });\n      }\n    }).on(\"move\", function (_a) {\n      var offsetX = _a.offsetX,\n        offsetY = _a.offsetY,\n        inputEvent = _a.inputEvent;\n      var gesto = _this.gesto;\n      if (!gesto || !gesto.isFlag()) {\n        return;\n      }\n      var data = _this.gesto.getEventData();\n      var boundArea = data.boundArea;\n      data.startX -= offsetX;\n      data.startY -= offsetY;\n      var innerScrollOptions = _this.gesto.getEventData().innerScrollOptions;\n      var container = innerScrollOptions === null || innerScrollOptions === void 0 ? void 0 : innerScrollOptions.container;\n      var isMoveInnerScroll = false;\n      if (container) {\n        var parentMap_2 = data.selectableInnerScrollParentMap;\n        var parentInfo = parentMap_2.get(container);\n        if (parentInfo) {\n          parentInfo.paths.forEach(function (scrollContainer) {\n            var containerInfo = parentMap_2.get(scrollContainer);\n            containerInfo.points.forEach(function (pos) {\n              pos[0] -= offsetX;\n              pos[1] -= offsetY;\n            });\n          });\n          parentInfo.indexes.forEach(function (index) {\n            data.selectablePoints[index].forEach(function (pos) {\n              pos[0] -= offsetX;\n              pos[1] -= offsetY;\n            });\n          });\n          isMoveInnerScroll = true;\n        }\n      }\n      if (!isMoveInnerScroll) {\n        data.selectablePoints.forEach(function (points) {\n          points.forEach(function (pos) {\n            pos[0] -= offsetX;\n            pos[1] -= offsetY;\n          });\n        });\n      }\n      _this._refreshGroups(data);\n      boundArea.left -= offsetX;\n      boundArea.right -= offsetX;\n      boundArea.top -= offsetY;\n      boundArea.bottom -= offsetY;\n      _this.gesto.scrollBy(offsetX, offsetY, inputEvent.inputEvent);\n      _this._checkSelected(_this.gesto.getCurrentEvent());\n    });\n  };\n  __proto._select = function (selectedTargets, rect, e, isStart, isDragStartEnd) {\n    if (isDragStartEnd === void 0) {\n      isDragStartEnd = false;\n    }\n    var inputEvent = e.inputEvent;\n    var data = e.data;\n    var result = this.setSelectedTargets(selectedTargets);\n    var _a = diff(data.startSelectedTargets, selectedTargets),\n      added = _a.added,\n      removed = _a.removed,\n      prevList = _a.prevList,\n      list = _a.list;\n    var startResult = {\n      startSelected: prevList,\n      startAdded: added.map(function (i) {\n        return list[i];\n      }),\n      startRemoved: removed.map(function (i) {\n        return prevList[i];\n      })\n    };\n    if (isStart) {\n      /**\n       * When the select(drag) starts, the selectStart event is called.\n       * @memberof Selecto\n       * @event selectStart\n       * @param {Selecto.OnSelect} - Parameters for the selectStart event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"selectStart\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * }).on(\"selectEnd\", e => {\n       *   e.afterAdded.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.afterRemoved.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n      this.emit(\"selectStart\", __assign(__assign(__assign({}, result), startResult), {\n        rect: rect,\n        inputEvent: inputEvent,\n        data: data.data,\n        isTrusted: e.isTrusted,\n        isDragStartEnd: isDragStartEnd\n      }));\n    }\n    if (result.added.length || result.removed.length) {\n      /**\n       * When the select in real time, the select event is called.\n       * @memberof Selecto\n       * @event select\n       * @param {Selecto.OnSelect} - Parameters for the select event\n       * @example\n       * import Selecto from \"selecto\";\n       *\n       * const selecto = new Selecto({\n       *   container: document.body,\n       *   selectByClick: true,\n       *   selectFromInside: false,\n       * });\n       *\n       * selecto.on(\"select\", e => {\n       *   e.added.forEach(el => {\n       *     el.classList.add(\"selected\");\n       *   });\n       *   e.removed.forEach(el => {\n       *     el.classList.remove(\"selected\");\n       *   });\n       * });\n       */\n      this.emit(\"select\", __assign(__assign(__assign({}, result), startResult), {\n        rect: rect,\n        inputEvent: inputEvent,\n        data: data.data,\n        isTrusted: e.isTrusted,\n        isDragStartEnd: isDragStartEnd\n      }));\n    }\n  };\n  __proto._selectEnd = function (startSelectedTargets, startPassedTargets, rect, e, isDragStartEnd) {\n    if (isDragStartEnd === void 0) {\n      isDragStartEnd = false;\n    }\n    var inputEvent = e.inputEvent,\n      isDouble = e.isDouble,\n      data = e.data;\n    var type = inputEvent && inputEvent.type;\n    var isDragStart = type === \"mousedown\" || type === \"touchstart\";\n    var _a = diff(startSelectedTargets, this.selectedTargets),\n      added = _a.added,\n      removed = _a.removed,\n      prevList = _a.prevList,\n      list = _a.list;\n    var _b = diff(startPassedTargets, this.selectedTargets),\n      afterAdded = _b.added,\n      afterRemoved = _b.removed,\n      afterPrevList = _b.prevList,\n      afterList = _b.list;\n    /**\n     * When the select(dragEnd or click) ends, the selectEnd event is called.\n     * @memberof Selecto\n     * @event selectEnd\n     * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"selectStart\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * }).on(\"selectEnd\", e => {\n     *   e.afterAdded.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.afterRemoved.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n\n    this.emit(\"selectEnd\", {\n      startSelected: startSelectedTargets,\n      beforeSelected: startPassedTargets,\n      selected: this.selectedTargets,\n      added: added.map(function (index) {\n        return list[index];\n      }),\n      removed: removed.map(function (index) {\n        return prevList[index];\n      }),\n      afterAdded: afterAdded.map(function (index) {\n        return afterList[index];\n      }),\n      afterRemoved: afterRemoved.map(function (index) {\n        return afterPrevList[index];\n      }),\n      isDragStart: isDragStart && isDragStartEnd,\n      isDragStartEnd: isDragStart && isDragStartEnd,\n      isClick: !!e.isClick,\n      isDouble: !!isDouble,\n      rect: rect,\n      inputEvent: inputEvent,\n      data: data.data,\n      isTrusted: e.isTrusted\n    });\n  };\n  __proto._checkSelected = function (e, rect) {\n    if (rect === void 0) {\n      rect = getRect(e, this.options.ratio);\n    }\n    var data = e.data;\n    var top = rect.top,\n      left = rect.left,\n      width = rect.width,\n      height = rect.height;\n    var selectFlag = data.selectFlag;\n    var containerX = data.containerX,\n      containerY = data.containerY,\n      scaleMatrix = data.scaleMatrix;\n    var offsetPos = calculateMatrixDist(scaleMatrix, [left - containerX, top - containerY]);\n    var offsetSize = calculateMatrixDist(scaleMatrix, [width, height]);\n    var selectedTargets = [];\n    if (selectFlag) {\n      this.target.style.cssText += \"display: block;\" + \"left:0px;top:0px;\" + \"transform: translate(\".concat(offsetPos[0], \"px, \").concat(offsetPos[1], \"px);\") + \"width:\".concat(offsetSize[0], \"px;height:\").concat(offsetSize[1], \"px;\");\n      var passedTargets = this.hitTest(rect, data, true, e);\n      selectedTargets = passTargets(data.startPassedTargets, passedTargets, this.continueSelect && this.continueSelectWithoutDeselect);\n    }\n    /**\n     * When the drag, the drag event is called.\n     * Call the stop () function if you have a specific element or don't want to raise a select\n     * @memberof Selecto\n     * @event drag\n     * @param {OnDrag} - Parameters for the drag event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto({\n     *   container: document.body,\n     *   selectByClick: true,\n     *   selectFromInside: false,\n     * });\n     *\n     * selecto.on(\"drag\", e => {\n     *   e.stop();\n     * }).on(\"select\", e => {\n     *   e.added.forEach(el => {\n     *     el.classList.add(\"selected\");\n     *   });\n     *   e.removed.forEach(el => {\n     *     el.classList.remove(\"selected\");\n     *   });\n     * });\n     */\n\n    var result = this.emit(\"drag\", __assign(__assign({}, e), {\n      data: data.data,\n      isSelect: selectFlag,\n      rect: rect\n    }));\n    if (result === false) {\n      this.target.style.cssText += \"display: none;\";\n      e.stop();\n      return;\n    }\n    if (selectFlag) {\n      this._select(selectedTargets, rect, e);\n    }\n  };\n  __proto._sameCombiKey = function (e, keys, isKeyup) {\n    if (!keys) {\n      return false;\n    }\n    var combi = getCombi(e.inputEvent, e.key);\n    var nextKeys = [].concat(keys);\n    var toggleKeys = isArray(nextKeys[0]) ? nextKeys : [nextKeys];\n    if (isKeyup) {\n      var singleKey_1 = e.key;\n      return toggleKeys.some(function (keys) {\n        return keys.some(function (key) {\n          return key === singleKey_1;\n        });\n      });\n    }\n    return toggleKeys.some(function (keys) {\n      return keys.every(function (key) {\n        return combi.indexOf(key) > -1;\n      });\n    });\n  };\n  __proto._findElement = function (clickedTarget, selectableTargets) {\n    var pointTarget = clickedTarget;\n    while (pointTarget) {\n      if (selectableTargets.indexOf(pointTarget) > -1) {\n        break;\n      }\n      pointTarget = pointTarget.parentElement;\n    }\n    return pointTarget;\n  };\n  __proto._refreshGroups = function (data) {\n    var _a;\n    var innerWidth = data.innerWidth;\n    var innerHeight = data.innerHeight;\n    var selectablePoints = data.selectablePoints;\n    if (this.options.checkOverflow) {\n      var innerScrollContainer_1 = (_a = this.gesto.getEventData().innerScrollOptions) === null || _a === void 0 ? void 0 : _a.container;\n      var parentMap_3 = data.selectableInnerScrollParentMap;\n      var innerScrollPathsList = data.selectableInnerScrollPathsList;\n      data.selectableInners = innerScrollPathsList.map(function (innerScrollPaths, i) {\n        var isAlwaysTrue = false;\n        return innerScrollPaths.every(function (target) {\n          if (isAlwaysTrue) {\n            return true;\n          }\n          if (target === innerScrollContainer_1) {\n            isAlwaysTrue = true;\n            return true;\n          }\n          var rect = parentMap_3.get(target);\n          if (rect) {\n            var points1 = selectablePoints[i];\n            var points2 = rect.points;\n            var overlapPoints = getOverlapPoints(points1, points2);\n            if (!overlapPoints.length) {\n              return false;\n            }\n          }\n          return true;\n        });\n      });\n    }\n    if (!innerWidth || !innerHeight) {\n      data.innerGroups = null;\n    } else {\n      var selectablePoints_1 = data.selectablePoints;\n      var groups_1 = {};\n      selectablePoints_1.forEach(function (points, i) {\n        var minX = Infinity;\n        var maxX = -Infinity;\n        var minY = Infinity;\n        var maxY = -Infinity;\n        points.forEach(function (pos) {\n          var x = Math.floor(pos[0] / innerWidth);\n          var y = Math.floor(pos[1] / innerHeight);\n          minX = Math.min(x, minX);\n          maxX = Math.max(x, maxX);\n          minY = Math.min(y, minY);\n          maxY = Math.max(y, maxY);\n        });\n        for (var x = minX; x <= maxX; ++x) {\n          for (var y = minY; y <= maxY; ++y) {\n            groups_1[x] = groups_1[x] || {};\n            groups_1[x][y] = groups_1[x][y] || [];\n            groups_1[x][y].push(i);\n          }\n        }\n      });\n      data.innerGroups = groups_1;\n    }\n  };\n  Selecto = __decorate([Properties(PROPERTIES, function (prototype, property) {\n    var attributes = {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        return this.options[property];\n      }\n    };\n    var getter = camelize(\"get \".concat(property));\n    if (prototype[getter]) {\n      attributes.get = function () {\n        return this[getter]();\n      };\n    } else {\n      attributes.get = function () {\n        return this.options[property];\n      };\n    }\n    var setter = camelize(\"set \".concat(property));\n    if (prototype[setter]) {\n      attributes.set = function (value) {\n        this[setter](value);\n      };\n    } else {\n      attributes.set = function (value) {\n        this.options[property] = value;\n      };\n    }\n    Object.defineProperty(prototype, property, attributes);\n  })], Selecto);\n  return Selecto;\n}(EventEmitter);\nvar Selecto$1 = /*#__PURE__*/\nfunction (_super) {\n  __extends(Selecto, _super);\n  function Selecto() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  return Selecto;\n}(Selecto);\nexport default Selecto$1;\nexport { CLASS_NAME, EVENTS, METHODS, OPTIONS, OPTION_TYPES, PROPERTIES };","map":{"version":3,"names":["getClient","e","touch","touches","changedTouches","clientX","clientY","filterDuplicated","arr","Map","filter","value","index","indexOf","map","has","set","elementFromPoint","baseNode","doc","getDocument","createElement","jsx","prevTarget","container","tag","children","attributes","className","style","el","name","setAttribute","elChildren","forEach","child","i","split","hasClass","addClass","elStyle","appendChild","h","attrs","_i","arguments","length","_a","_b","_c","__rest","diffValue","prev","cur","func","getRect","ratio","boundArea","data","distX","distY","_d","startX","startY","nextHeight","Math","sqrt","nextWidth","width","abs","height","maxWidth","left","right","maxHeight","top","bottom","calculateBoundSize","tx","min","ty","getDefaultElementRect","rect","getBoundingClientRect","pos1","pos2","pos3","pos4","passTargets","beforeTargets","afterTargets","continueSelectWithoutDeselect","diff","list","prevList","added","removed","maintained","__spreadArray","nextIndex","getLineSize","points","size","max","getDist","injector","styled","CLASS_NAME","concat","PROPERTIES","OPTIONS","OPTION_TYPES","String","boundContainer","portalContainer","dragContainer","selectableTargets","Array","selectByClick","Boolean","selectFromInside","continueSelect","toggleContinueSelect","toggleContinueSelectWithoutDeselect","keyContainer","hitRate","Number","scrollOptions","Object","checkInput","preventDefault","cspNonce","getElementRect","Function","preventDragFromInside","rootContainer","dragCondition","clickBySelectEnd","preventClickEventOnDragStart","preventClickEventOnDrag","checkOverflow","innerScrollOptions","EVENTS","METHODS","Selecto","__extends","_super","options","_this","call","selectedTargets","dragScroll","DragScroll","_onDragStart","clickedTarget","inputEvent","stop","win","getWindow","innerWidth","innerHeight","findSelectableTargets","startSelectedTargets","scaleMatrix","createMatrix","containerX","containerY","Infinity","containerRect","getDistElementMatrix","boundInfo","isObject","__assign","element","boundElement","rectElement","isString","querySelector","hitRect","firstPassedTargets","allowClickBySelectEnd","hasInsideTargets","pointTarget","_findElement","target","isPreventSelect","type","isTrusted","result","isClick","emit","startPassedTargets","_select","selectFlag","offsetPos","calculateMatrixDist","cssText","_selectEnd","isInnerScroll","inputEvent_1","innerScrollElement","parentElement","body","overflow","getComputedStyle","checkScrollEvent","dragStart","preventDrag","_onDrag","hasScrollOptions","isScroll","drag","_checkSelected","_onDragEnd","isDouble","isDrag","isSelect","dragEnd","_onKeyDown","isKeyDown","_keydownContinueSelect","_sameCombiKey","_keydownContinueSelectWithoutDeselection","keydownContinueSelect","keydownContinueSelectWithoutDeselection","_onKeyUp","isKeyUp","_onBlur","_onDocumentSelectStart","gesto","isFlag","documentElement","containers","isNode","slice","some","contains","document","initElement","initDragScroll","setKeyController","__proto","setSelectedTargets","beforeSelected","selected","setSelectedTargetsByPoints","point1","point2","ignoreClick","selectedElements","hitTest","selectTargetsByPoints","startPoint","endPoint","mousedown","MouseEvent","cancelable","bubbles","mousemove","mouseup","onDragStart","onDrag","onDragEnd","getSelectedTargets","triggerDragStart","destroy","off","keycon","unset","injectResult","removeEvent","removeChild","getElementPoints","info","fitPoints","getSelectableElements","selectableElements","isFunction","push","apply","current","elements","querySelectorAll","checkScroll","getEventData","getCurrentEvent","selectablePoints","selectableParentMap","hasIndexesMap","parentMap_1","selectableInnerScrollParentMap","selectableInnerScrollPathsList","parents","paths","get","indexes","prevParentElement","selectableInners","_refreshGroups","clickTarget","dragEvent","KeyController","keydown","keyup","on","setClassName","nextClassName","setKeyEvent","setKeyContainer","getContinueSelect","getContinueSelectWithoutDeselect","setToggleContinueSelect","setToggleContinueSelectWithoutDeselect","setPreventDefault","setCheckInput","preventClickEventByCondition","preventRightClick","parentNode","Gesto","checkWindowBlur","addEvent","inject","nonce","selectRect","gestoEvent","innerGroups","rectPoints","isHit","hitRateValue","splitUnit","inArea","isInside","overlapPoints","getOverlapPoints","overlapSize","getAreaSize","targetSize","unit","rate","between","round","_","minX","floor","maxX","minY","maxY","x","yGroups","y","group","inner","next","direction","offsetX","offsetY","isMoveInnerScroll","parentMap_2","parentInfo","scrollContainer","containerInfo","pos","scrollBy","isStart","isDragStartEnd","startResult","startSelected","startAdded","startRemoved","isDragStart","afterAdded","afterRemoved","afterPrevList","afterList","offsetSize","passedTargets","keys","isKeyup","combi","getCombi","key","nextKeys","toggleKeys","isArray","singleKey_1","every","innerScrollContainer_1","parentMap_3","innerScrollPathsList","innerScrollPaths","isAlwaysTrue","points1","points2","selectablePoints_1","groups_1","__decorate","Properties","prototype","property","enumerable","configurable","getter","camelize","setter","defineProperty","EventEmitter","Selecto$1"],"sources":["/Users/toshi/Document/AI/engineeringAI/QAservice/frontend/node_modules/selecto/src/utils.ts","/Users/toshi/Document/AI/engineeringAI/QAservice/frontend/node_modules/selecto/src/consts.ts","/Users/toshi/Document/AI/engineeringAI/QAservice/frontend/node_modules/selecto/src/SelectoManager.tsx","/Users/toshi/Document/AI/engineeringAI/QAservice/frontend/node_modules/selecto/src/Selecto.tsx"],"sourcesContent":["import type { ElementType, Hypertext, Point, Rect } from \"./types\";\nimport { IObject, addClass, hasClass, calculateBoundSize, getDist, getDocument } from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport { getMinMaxs } from \"overlap-area\";\n\nexport function getClient(e: MouseEvent | TouchEvent) {\n    if (\"touches\" in e) {\n        const touch = e.touches[0] || e.changedTouches[0];\n\n        return {\n            clientX: touch.clientX,\n            clientY: touch.clientY,\n        };\n    } else {\n        return {\n            clientX: e.clientX,\n            clientY: e.clientY,\n        };\n    }\n}\nexport function filterDuplicated<T>(arr: T[]): T[] {\n    if (typeof Map === \"undefined\") {\n        return arr.filter((value, index) => {\n            return arr.indexOf(value) === index;\n        });\n    }\n    const map = new Map<T, true>();\n    return arr.filter(value => {\n        if (map.has(value)) {\n            return false;\n        }\n        map.set(value, true);\n        return true;\n    });\n}\n\nexport function elementFromPoint(baseNode: Node, clientX: number, clientY: number): ElementType | null {\n    const doc = getDocument(baseNode);\n\n    return (doc.elementFromPoint && doc.elementFromPoint(clientX, clientY)) as any || null;\n}\n\nexport function createElement(\n    jsx: Hypertext,\n    prevTarget?: ElementType,\n    container?: ElementType,\n) {\n    const { tag, children, attributes, className, style } = jsx;\n    const el = prevTarget || getDocument(container).createElement(tag) as ElementType;\n\n    for (const name in attributes) {\n        el.setAttribute(name, attributes[name]);\n    }\n    const elChildren = el.children;\n    children.forEach((child, i) => {\n        createElement(child, elChildren[i] as ElementType, el);\n    });\n    if (className) {\n        className.split(/\\s+/g).forEach(name => {\n            if (name && !hasClass(el, name)) {\n                addClass(el, name);\n            }\n        });\n    }\n    if (style) {\n        const elStyle = el.style;\n        for (const name in style) {\n            elStyle[name] = style[name];\n        }\n    }\n    if (!prevTarget && container) {\n        container.appendChild(el);\n    }\n    return el;\n}\nexport function h(\n    tag: string,\n    attrs: IObject<any>,\n    ...children: Hypertext[]\n): Hypertext {\n    const {\n        className = \"\",\n        style = {},\n        ...attributes\n    } = attrs || {};\n    return {\n        tag,\n        className,\n        style,\n        attributes,\n        children,\n    };\n}\n\nexport function diffValue<T>(prev: T, cur: T, func: (prev: T, cur: T) => void) {\n    if (prev !== cur) {\n        func(prev, cur);\n    }\n}\nexport function isFastInside(point: number[], points: number[][]) {\n    const { minX, minY, maxX, maxY } = getMinMaxs(points);\n    const [x, y] = point;\n\n    return minX <= x && x <= maxX && minY <= y && y <= maxY;\n}\nexport function getFastOverlapPoints(points1: number[][], points2: number[][]) {\n    const {\n        minX: minX1,\n        minY: minY1,\n        maxX: maxX1,\n        maxY: maxY1,\n    } = getMinMaxs(points1);\n    const {\n        minX: minX2,\n        minY: minY2,\n        maxX: maxX2,\n        maxY: maxY2,\n    } = getMinMaxs(points2);\n\n    if (maxX2 < minX1 || maxX1 < minX2 || maxY2 < minY1 || maxY1 < minY2) {\n        return [];\n    }\n    const width = Math.min(maxX2 - minX1, maxX1 - minX2);\n    const height = Math.min(maxY2 - minY1, maxY1 - minY2);\n\n    return [\n        [0, 0],\n        [width, 0],\n        [width, height],\n        [0, height],\n    ];\n}\nexport function getRect(\n    e: any, ratio: number,\n    boundArea = e.data.boundArea,\n): Rect {\n    let {\n        distX = 0,\n        distY = 0,\n    } = e;\n    const { startX, startY } = e.data;\n\n    if (ratio > 0) {\n        const nextHeight = Math.sqrt((distX * distX + distY * distY) / (1 + ratio * ratio));\n        const nextWidth = ratio * nextHeight;\n\n        distX = (distX >= 0 ? 1 : -1) * nextWidth;\n        distY = (distY >= 0 ? 1 : -1) * nextHeight;\n    }\n    let width = Math.abs(distX);\n    let height = Math.abs(distY);\n\n    const maxWidth = distX < 0 ? startX - boundArea.left : boundArea.right - startX;\n    const maxHeight = distY < 0 ? startY - boundArea.top : boundArea.bottom - startY;\n\n    [width, height] = calculateBoundSize([width, height], [0, 0], [maxWidth, maxHeight], !!ratio);\n    distX = (distX >= 0 ? 1 : -1) * width;\n    distY = (distY >= 0 ? 1 : -1) * height;\n\n    const tx = Math.min(0, distX);\n    const ty = Math.min(0, distY);\n    const left = startX + tx;\n    const top = startY + ty;\n\n    return {\n        left,\n        top,\n        right: left + width,\n        bottom: top + height,\n        width,\n        height,\n    };\n}\n\nexport function getDefaultElementRect(el: ElementType): Point {\n    const rect = el.getBoundingClientRect();\n    const { left, top, width, height } = rect;\n\n    return {\n        pos1: [left, top],\n        pos2: [left + width, top],\n        pos3: [left, top + height],\n        pos4: [left + width, top + height],\n    };\n}\n\nexport function passTargets(\n    beforeTargets: ElementType[],\n    afterTargets: ElementType[],\n    continueSelectWithoutDeselect: boolean,\n) {\n    const {\n        list,\n        prevList,\n        added,\n        removed,\n        maintained,\n    } = diff(beforeTargets, afterTargets);\n\n    return [\n        ...added.map(index => list[index]),\n        ...removed.map(index => prevList[index]),\n        ...continueSelectWithoutDeselect ? maintained.map(([, nextIndex]) => list[nextIndex]) : [],\n    ];\n}\n\nexport function getLineSize(points: number[][]) {\n    let size = 0;\n    const length = points.length;\n\n    for (let i = 1; i < length; ++i) {\n        size = Math.max(getDist(points[i], points[i - 1]), size);\n    }\n\n    return size;\n}\n","import styled from \"css-styled\";\nimport { SelectoOptions } from \"./types\";\n\nexport const injector = styled(`\n:host {\n    position: fixed;\n    display: none;\n    border: 1px solid #4af;\n    background: rgba(68, 170, 255, 0.5);\n    pointer-events: none;\n    will-change: transform;\n    z-index: 100;\n}\n`);\n\n/**\n * @memberof Selecto\n */\nexport const CLASS_NAME = `selecto-selection ${injector.className}`;\n\nexport const PROPERTIES = [\n    \"className\",\n    \"boundContainer\",\n    \"selectableTargets\",\n    \"selectByClick\",\n    \"selectFromInside\",\n    \"continueSelect\",\n    \"continueSelectWithoutDeselect\",\n    \"toggleContinueSelect\",\n    \"toggleContinueSelectWithoutDeselect\",\n    \"keyContainer\",\n    \"hitRate\",\n    \"scrollOptions\",\n    \"checkInput\",\n    \"preventDefault\",\n    \"ratio\",\n    \"getElementRect\",\n    \"preventDragFromInside\",\n    \"rootContainer\",\n    \"dragCondition\",\n    \"clickBySelectEnd\",\n    \"checkOverflow\",\n    \"innerScrollOptions\",\n] as const;\n/**\n * @memberof Selecto\n */\nexport const OPTIONS = [\n    // ignore target, container,\n    \"dragContainer\",\n    \"cspNonce\",\n    \"preventClickEventOnDrag\",\n    \"preventClickEventOnDragStart\",\n    \"preventRightClick\",\n    ...PROPERTIES,\n] as const;\n\nexport const OPTION_TYPES: { [key in keyof SelectoOptions]: any } = {\n    className: String,\n    boundContainer: null,\n    portalContainer: null,\n    container: null,\n    dragContainer: null,\n    selectableTargets: Array,\n    selectByClick: Boolean,\n    selectFromInside: Boolean,\n    continueSelect: Boolean,\n    toggleContinueSelect: Array,\n    toggleContinueSelectWithoutDeselect: Array,\n    keyContainer: null,\n    hitRate: Number,\n    scrollOptions: Object,\n    checkInput: Boolean,\n    preventDefault: Boolean,\n    cspNonce: String,\n    ratio: Number,\n    getElementRect: Function,\n    preventDragFromInside: Boolean,\n    rootContainer: Object,\n    dragCondition: Function,\n    clickBySelectEnd: Boolean,\n    continueSelectWithoutDeselect: Boolean,\n    preventClickEventOnDragStart: Boolean,\n    preventClickEventOnDrag: Boolean,\n    checkOverflow: Boolean,\n    innerScrollOptions: Object,\n};\n\n/**\n * @memberof Selecto\n */\nexport const EVENTS = [\n    \"dragStart\",\n    \"drag\",\n    \"dragEnd\",\n    \"selectStart\",\n    \"select\",\n    \"selectEnd\",\n    \"keydown\",\n    \"keyup\",\n    \"scroll\",\n    \"innerScroll\",\n] as const;\n\n/**\n * @memberof Selecto\n */\nexport const METHODS = [\n    \"clickTarget\",\n    \"getSelectableElements\",\n    \"setSelectedTargets\",\n    \"getElementPoints\",\n    \"getSelectedTargets\",\n    \"findSelectableTargets\",\n    \"triggerDragStart\",\n    \"checkScroll\",\n    \"selectTargetsByPoints\",\n    \"setSelectedTargetsByPoints\",\n] as const;\n","import EventEmitter from \"@scena/event-emitter\";\nimport Gesto, { OnDrag } from \"gesto\";\nimport { InjectResult } from \"css-styled\";\nimport { Properties } from \"framework-utils\";\nimport {\n    isObject,\n    camelize,\n    IObject,\n    addEvent,\n    removeEvent,\n    isArray,\n    isString,\n    between,\n    splitUnit,\n    isFunction,\n    getWindow,\n    getDocument,\n    isNode,\n} from \"@daybrush/utils\";\nimport { diff } from \"@egjs/children-differ\";\nimport DragScroll from \"@scena/dragscroll\";\nimport KeyController, { KeyControllerEvent, getCombi } from \"keycon\";\nimport {\n    getAreaSize,\n    getOverlapPoints,\n    isInside,\n    fitPoints,\n} from \"overlap-area\";\nimport { getDistElementMatrix, calculateMatrixDist, createMatrix } from \"css-to-mat\";\nimport {\n    createElement,\n    h,\n    getClient,\n    diffValue,\n    getRect,\n    getDefaultElementRect,\n    passTargets,\n    elementFromPoint,\n    filterDuplicated,\n    getLineSize,\n} from \"./utils\";\nimport {\n    SelectoOptions,\n    SelectoProperties,\n    OnDragEvent,\n    SelectoEvents,\n    Rect,\n    BoundContainer,\n    SelectedTargets,\n    SelectedTargetsWithRect,\n    InnerParentInfo,\n    ElementType,\n    OnDragStart,\n} from \"./types\";\nimport { PROPERTIES, injector, CLASS_NAME } from \"./consts\";\n\n/**\n * Selecto.js is a component that allows you to select elements in the drag area using the mouse or touch.\n * @sort 1\n * @extends EventEmitter\n */\n@Properties(PROPERTIES as any, (prototype, property) => {\n    const attributes: IObject<any> = {\n        enumerable: true,\n        configurable: true,\n        get() {\n            return this.options[property];\n        },\n    };\n    const getter = camelize(`get ${property}`);\n    if (prototype[getter]) {\n        attributes.get = function() {\n            return this[getter]();\n        };\n    } else {\n        attributes.get = function() {\n            return this.options[property];\n        };\n    }\n    const setter = camelize(`set ${property}`);\n    if (prototype[setter]) {\n        attributes.set = function(value: any) {\n            this[setter](value);\n        };\n    } else {\n        attributes.set = function(value: any) {\n            this.options[property] = value;\n        };\n    }\n    Object.defineProperty(prototype, property, attributes);\n})\n\nclass Selecto extends EventEmitter<SelectoEvents> {\n    public options: SelectoOptions;\n    private target!: ElementType;\n    private dragContainer!: Element | Window | Element[];\n    private container!: HTMLElement;\n    private gesto!: Gesto;\n    private injectResult!: InjectResult;\n    private selectedTargets: ElementType[] = [];\n    private dragScroll: DragScroll = new DragScroll();\n    private keycon!: KeyController;\n    private _keydownContinueSelect: boolean;\n    private _keydownContinueSelectWithoutDeselection: boolean;\n    /**\n     *\n     */\n    constructor(options: Partial<SelectoOptions> = {}) {\n        super();\n        this.target = options.portalContainer;\n        let container = options.container;\n        this.options = {\n            className: \"\",\n            portalContainer: null,\n            container: null,\n            dragContainer: null,\n            selectableTargets: [],\n            selectByClick: true,\n            selectFromInside: true,\n            clickBySelectEnd: false,\n            hitRate: 100,\n            continueSelect: false,\n            continueSelectWithoutDeselect: false,\n            toggleContinueSelect: null,\n            toggleContinueSelectWithoutDeselect: null,\n            keyContainer: null,\n            scrollOptions: null,\n            checkInput: false,\n            preventDefault: false,\n            boundContainer: false,\n            preventDragFromInside: true,\n            dragCondition: null,\n            rootContainer: null,\n            checkOverflow: false,\n            innerScrollOptions: false,\n            getElementRect: getDefaultElementRect,\n            cspNonce: \"\",\n            ratio: 0,\n            ...options,\n        };\n        const portalContainer = this.options.portalContainer;\n\n        if (portalContainer) {\n            container = portalContainer.parentElement;\n        }\n        this.container = container || document.body;\n        this.initElement();\n        this.initDragScroll();\n        this.setKeyController();\n    }\n    /**\n     * You can set the currently selected targets.\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    public setSelectedTargets(\n        selectedTargets: ElementType[],\n    ): SelectedTargets {\n        const beforeSelected = this.selectedTargets;\n        const { added, removed, prevList, list } = diff(\n            beforeSelected,\n            selectedTargets\n        );\n        this.selectedTargets = selectedTargets;\n\n        return {\n            added: added.map(index => list[index]),\n            removed: removed.map(index => prevList[index]),\n            beforeSelected,\n            selected: selectedTargets,\n        };\n    }\n    /**\n     * You can set the currently selected targets by points\n     * selectByClick, continueSelect, and continueSelectWithoutDeselect are not applied.\n     */\n    public setSelectedTargetsByPoints(\n        point1: number[],\n        point2: number[],\n    ): SelectedTargetsWithRect {\n        const left = Math.min(point1[0], point2[0]);\n        const top = Math.min(point1[1], point2[1]);\n        const right = Math.max(point1[0], point2[0]);\n        const bottom = Math.max(point1[1], point2[1]);\n        const rect: Rect = {\n            left,\n            top,\n            right,\n            bottom,\n            width: right - left,\n            height: bottom - top,\n        };\n        const data = { ignoreClick: true };\n\n        this.findSelectableTargets(data);\n        const selectedElements = this.hitTest(rect, data, true, null);\n        const result = this.setSelectedTargets(selectedElements);\n\n        return {\n            ...result,\n            rect,\n        };\n    }\n    /**\n     * Select target by virtual drag from startPoint to endPoint.\n     * The target of inputEvent is null.\n     */\n    public selectTargetsByPoints(\n        startPoint: number[],\n        endPoint: number[],\n    ) {\n        const mousedown = new MouseEvent(\"mousedown\", {\n            clientX: startPoint[0],\n            clientY: startPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const mousemove = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const mouseup = new MouseEvent(\"mousemove\", {\n            clientX: endPoint[0],\n            clientY: endPoint[1],\n            cancelable: true,\n            bubbles: true,\n        });\n        const gesto = this.gesto;\n        const result = gesto.onDragStart(mousedown);\n\n        if (result !== false) {\n            gesto.onDrag(mousemove);\n            gesto.onDragEnd(mouseup);\n        }\n    }\n    /**\n     * You can get the currently selected targets.\n     */\n    public getSelectedTargets(): ElementType[] {\n        return this.selectedTargets;\n    }\n    /**\n     * `OnDragStart` is triggered by an external event.\n     * @param - external event\n     * @example\n     * import Selecto from \"selecto\";\n     *\n     * const selecto = new Selecto();\n     *\n     * window.addEventListener(\"mousedown\", e => {\n     *   selecto.triggerDragStart(e);\n     * });\n     */\n    public triggerDragStart(e: MouseEvent | TouchEvent) {\n        this.gesto.triggerDragStart(e);\n        return this;\n    }\n    /**\n     * Destroy elements, properties, and events.\n     */\n    public destroy() {\n        this.off();\n        this.keycon && this.keycon.destroy();\n        this.gesto.unset();\n        this.injectResult.destroy();\n        this.dragScroll.dragEnd();\n        removeEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n        if (!this.options.portalContainer) {\n            this.target.parentElement?.removeChild(this.target);\n        }\n\n\n        this.keycon = null;\n        this.gesto = null;\n        this.injectResult = null;\n        this.target = null;\n        this.container = null;\n        this.options = null;\n    }\n    public getElementPoints(target: ElementType) {\n        const getElementRect = this.getElementRect || getDefaultElementRect;\n        const info = getElementRect(target);\n        const points = [info.pos1, info.pos2, info.pos4, info.pos3];\n\n        if (getElementRect !== getDefaultElementRect) {\n            const rect = target.getBoundingClientRect();\n\n            return fitPoints(points, rect);\n        }\n        return points;\n    }\n    /**\n     * Get all elements set in `selectableTargets`.\n     */\n    public getSelectableElements() {\n        const container = this.container;\n        const selectableElements: ElementType[] = [];\n\n        this.options.selectableTargets.forEach((target) => {\n            if (isFunction(target)) {\n                const result = target();\n\n                if (result) {\n                    selectableElements.push(...[].slice.call(result));\n                }\n            } else if (isNode(target)) {\n                selectableElements.push(target);\n            } else if (isObject(target)) {\n                selectableElements.push(target.value || target.current);\n            } else {\n                const elements = [].slice.call(\n                    (getDocument(container)).querySelectorAll(target)\n                );\n\n                selectableElements.push(...elements);\n            }\n        });\n\n        return selectableElements;\n    }\n    /**\n     * If scroll occurs during dragging, you can manually call this method to check the position again.\n     */\n    public checkScroll() {\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        const scrollOptions = this.scrollOptions;\n        const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n        const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n        // If it is a scrolling position, pass drag\n        if (hasScrollOptions) {\n            this.dragScroll.checkScroll({\n                inputEvent: this.gesto.getCurrentEvent(),\n                ...(innerScrollOptions || scrollOptions),\n            });\n        }\n    }\n    /**\n     * Find for selectableTargets again during drag event\n     * You can update selectable targets during an event.\n     */\n    public findSelectableTargets(data: IObject<any> = this.gesto.getEventData()) {\n        const selectableTargets = this.getSelectableElements();\n        const selectablePoints = selectableTargets.map(\n            (target) => this.getElementPoints(target),\n        );\n\n        data.selectableTargets = selectableTargets;\n        data.selectablePoints = selectablePoints;\n        data.selectableParentMap = null;\n\n        const options = this.options;\n        const hasIndexesMap = options.checkOverflow || options.innerScrollOptions;\n        const doc = getDocument(this.container);\n\n        if (hasIndexesMap) {\n            const parentMap = new Map<Element, InnerParentInfo>();\n\n            data.selectableInnerScrollParentMap = parentMap;\n            data.selectableInnerScrollPathsList = selectableTargets.map((target, index) => {\n                let parentElement = target.parentElement;\n\n                let parents: Element[] = [];\n                const paths: Element[] = [];\n\n                while (parentElement && parentElement !== doc.body) {\n                    let info: InnerParentInfo = parentMap.get(parentElement);\n\n                    if (!info) {\n                        const overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n                        if (overflow) {\n                            const rect = getDefaultElementRect(parentElement);\n\n                            info = {\n                                parentElement,\n                                indexes: [],\n                                points: [rect.pos1, rect.pos2, rect.pos4, rect.pos3],\n                                paths: [...paths],\n                            };\n\n                            parents.push(parentElement);\n                            parents.forEach(prevParentElement => {\n                                parentMap.set(prevParentElement, info);\n                            });\n                            parents = [];\n                        }\n                    }\n                    if (info) {\n                        parentElement = info.parentElement;\n\n                        parentMap.get(parentElement).indexes.push(index);\n                        paths.push(parentElement);\n                    } else {\n                        parents.push(parentElement);\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n\n                return paths;\n            });\n        }\n\n        if (!options.checkOverflow) {\n            data.selectableInners = selectableTargets.map(() => true);\n        }\n\n        this._refreshGroups(data);\n\n        return selectableTargets;\n    }\n    /**\n     * External click or mouse events can be applied to the selecto.\n     * @params - Extenal click or mouse event\n     * @params - Specify the clicked target directly.\n     */\n    public clickTarget(\n        e: MouseEvent | TouchEvent,\n        clickedTarget?: Element\n    ): this {\n        const { clientX, clientY } = getClient(e);\n        const dragEvent = {\n            data: {\n                selectFlag: false,\n            },\n            clientX,\n            clientY,\n            inputEvent: e,\n            isClick: true,\n            isTrusted: false,\n            stop: () => {\n                return false;\n            },\n        } as any;\n        if (this._onDragStart(dragEvent, clickedTarget)) {\n            this._onDragEnd(dragEvent);\n        }\n        return this;\n    }\n    private setKeyController() {\n        const { keyContainer, toggleContinueSelect, toggleContinueSelectWithoutDeselect } = this.options;\n\n        if (this.keycon) {\n            this.keycon.destroy();\n            this.keycon = null;\n        }\n        if (toggleContinueSelect || toggleContinueSelectWithoutDeselect) {\n            this.keycon = new KeyController(keyContainer || getWindow(this.container));\n            this.keycon\n                .keydown(this._onKeyDown)\n                .keyup(this._onKeyUp)\n                .on(\"blur\", this._onBlur);\n        }\n    }\n    private setClassName(nextClassName: string) {\n        this.options.className = nextClassName;\n        this.target.setAttribute(`class`, `${CLASS_NAME} ${nextClassName || \"\"}`);\n    }\n    private setKeyEvent() {\n        const { toggleContinueSelect, toggleContinueSelectWithoutDeselect } = this.options;\n        if ((!toggleContinueSelect && !toggleContinueSelectWithoutDeselect) || this.keycon) {\n            return;\n        }\n        this.setKeyController();\n    }\n    // with getter, setter property\n    private setKeyContainer(keyContainer: HTMLElement | Document | Window) {\n        const options = this.options;\n\n        diffValue(options.keyContainer, keyContainer, () => {\n            options.keyContainer = keyContainer;\n\n            this.setKeyController();\n        });\n    }\n    private getContinueSelect() {\n        const {\n            continueSelect,\n            toggleContinueSelect,\n        } = this.options;\n\n        if (!toggleContinueSelect || !this._keydownContinueSelect) {\n            return continueSelect;\n        }\n        return !continueSelect;\n    }\n    private getContinueSelectWithoutDeselect() {\n        const {\n            continueSelectWithoutDeselect,\n            toggleContinueSelectWithoutDeselect,\n        } = this.options;\n\n        if (!toggleContinueSelectWithoutDeselect || !this._keydownContinueSelectWithoutDeselection) {\n            return continueSelectWithoutDeselect;\n        }\n        return !continueSelectWithoutDeselect;\n    }\n    private setToggleContinueSelect(\n        toggleContinueSelect: string[][] | string[] | string\n    ) {\n        const options = this.options;\n\n        diffValue(options.toggleContinueSelect, toggleContinueSelect, () => {\n            options.toggleContinueSelect = toggleContinueSelect;\n\n            this.setKeyEvent();\n        });\n    }\n    private setToggleContinueSelectWithoutDeselect(\n        toggleContinueSelectWithoutDeselect: string[][] | string[] | string\n    ) {\n        const options = this.options;\n\n        diffValue(options.toggleContinueSelectWithoutDeselect, toggleContinueSelectWithoutDeselect, () => {\n            options.toggleContinueSelectWithoutDeselect = toggleContinueSelectWithoutDeselect;\n\n            this.setKeyEvent();\n        });\n    }\n    private setPreventDefault(value: boolean) {\n        this.gesto.options.preventDefault = value;\n    }\n    private setCheckInput(value: boolean) {\n        this.gesto.options.checkInput = value;\n    }\n    private initElement() {\n        const {\n            dragContainer,\n            checkInput,\n            preventDefault,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n            preventRightClick = true,\n            className,\n        } = this.options;\n        const container = this.container;\n\n        this.target = createElement(\n            (<div className={`${CLASS_NAME} ${className || \"\"}`}></div>) as any,\n            this.target,\n            container,\n        );\n\n\n        const target = this.target;\n\n        this.dragContainer =\n            typeof dragContainer === \"string\"\n                ? [].slice.call(getDocument(container).querySelectorAll(dragContainer))\n                : dragContainer || (this.target.parentNode as any);\n        this.gesto = new Gesto(this.dragContainer, {\n            checkWindowBlur: true,\n            container: getWindow(container),\n            checkInput,\n            preventDefault,\n            preventClickEventOnDragStart,\n            preventClickEventOnDrag,\n            preventClickEventByCondition,\n            preventRightClick,\n        }).on({\n            dragStart: this._onDragStart,\n            drag: this._onDrag,\n            dragEnd: this._onDragEnd,\n        });\n        addEvent(document, \"selectstart\", this._onDocumentSelectStart);\n\n        this.injectResult = injector.inject(target, {\n            nonce: this.options.cspNonce,\n        });\n    }\n    private hitTest(\n        selectRect: Rect,\n        data: any,\n        isDrag: boolean,\n        gestoEvent: any,\n    ) {\n        const { hitRate, selectByClick } = this.options;\n        const { left, top, right, bottom } = selectRect;\n        const innerGroups: Record<string | number, Record<string | number, number[]>> = data.innerGroups;\n        const innerWidth = data.innerWidth;\n        const innerHeight = data.innerHeight;\n        const clientX = gestoEvent?.clientX;\n        const clientY = gestoEvent?.clientY;\n        const ignoreClick = data.ignoreClick;\n        const rectPoints = [\n            [left, top],\n            [right, top],\n            [right, bottom],\n            [left, bottom],\n        ];\n        const isHit = (points: number[][], el: Element) => {\n            const hitRateValue =\n                typeof hitRate === \"function\"\n                    ? splitUnit(`${hitRate(el)}`)\n                    : splitUnit(`${hitRate}`);\n\n            const inArea = ignoreClick\n                ? false\n                : isInside([clientX, clientY], points);\n\n            if (!isDrag && selectByClick && inArea) {\n                return true;\n            }\n            const overlapPoints = getOverlapPoints(rectPoints, points);\n\n            if (!overlapPoints.length) {\n                return false;\n            }\n            let overlapSize = getAreaSize(overlapPoints);\n\n            // Line\n            let targetSize = 0;\n\n            if (overlapSize === 0 && getAreaSize(points) === 0) {\n                targetSize = getLineSize(points);\n                overlapSize = getLineSize(overlapPoints);\n            } else {\n                targetSize = getAreaSize(points);\n            }\n\n\n            if (hitRateValue.unit === \"px\") {\n                return overlapSize >= hitRateValue.value;\n            } else {\n                const rate = between(\n                    Math.round((overlapSize / targetSize) * 100),\n                    0,\n                    100\n                );\n\n                return rate >= Math.min(100, hitRateValue.value);\n            }\n        };\n        const selectableTargets: ElementType[] = data.selectableTargets;\n        const selectablePoints: number[][][] = data.selectablePoints;\n        const selectableInners: boolean[] = data.selectableInners;\n\n        if (!innerGroups) {\n            return selectableTargets.filter((_, i) => {\n                if (!selectableInners[i]) {\n                    return false;\n                }\n                return isHit(selectablePoints[i], selectableTargets[i]);\n            });\n        }\n        const selectedTargets: ElementType[] = [];\n        const minX = Math.floor(left / innerWidth);\n        const maxX = Math.floor(right / innerWidth);\n        const minY = Math.floor(top / innerHeight);\n        const maxY = Math.floor(bottom / innerHeight);\n\n        for (let x = minX; x <= maxX; ++x) {\n            const yGroups = innerGroups[x];\n\n            if (!yGroups) {\n                continue;\n            }\n            for (let y = minY; y <= maxY; ++y) {\n                const group = yGroups[y];\n\n                if (!group) {\n                    continue;\n                }\n                group.forEach(index => {\n                    const points = selectablePoints[index];\n                    const inner = selectableInners[index];\n                    const target = selectableTargets[index];\n\n                    if (inner && isHit(points, target)) {\n                        selectedTargets.push(target);\n                    }\n                });\n            }\n        }\n        return filterDuplicated(selectedTargets);\n    }\n    private initDragScroll() {\n        this.dragScroll\n            .on(\"scrollDrag\", ({ next }) => {\n                next(this.gesto.getCurrentEvent());\n            })\n            .on(\"scroll\", ({ container, direction }) => {\n                const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n\n                if (innerScrollOptions) {\n                    this.emit(\"innerScroll\", {\n                        container,\n                        direction,\n                    });\n                } else {\n                    this.emit(\"scroll\", {\n                        container,\n                        direction,\n                    });\n                }\n            })\n            .on(\"move\", ({ offsetX, offsetY, inputEvent }) => {\n                const gesto = this.gesto;\n\n                if (!gesto || !gesto.isFlag()) {\n                    return;\n                }\n\n                const data = this.gesto.getEventData();\n                const boundArea = data.boundArea;\n\n                data.startX -= offsetX;\n                data.startY -= offsetY;\n\n                const innerScrollOptions = this.gesto.getEventData().innerScrollOptions;\n                const container = innerScrollOptions?.container;\n                let isMoveInnerScroll = false;\n\n                if (container) {\n                    const parentMap: Map<Element, InnerParentInfo> = data.selectableInnerScrollParentMap;\n                    const parentInfo = parentMap.get(container);\n\n                    if (parentInfo) {\n                        parentInfo.paths.forEach(scrollContainer => {\n                            const containerInfo = parentMap.get(scrollContainer);\n\n                            containerInfo.points.forEach(pos => {\n                                pos[0] -= offsetX;\n                                pos[1] -= offsetY;\n                            });\n                        });\n                        parentInfo.indexes.forEach(index => {\n                            data.selectablePoints[index].forEach((pos) => {\n                                pos[0] -= offsetX;\n                                pos[1] -= offsetY;\n                            });\n                        });\n                        isMoveInnerScroll = true;\n                    }\n                }\n                if (!isMoveInnerScroll) {\n                    data.selectablePoints.forEach((points: number[][]) => {\n                        points.forEach((pos) => {\n                            pos[0] -= offsetX;\n                            pos[1] -= offsetY;\n                        });\n                    });\n                }\n                this._refreshGroups(data);\n\n                boundArea.left -= offsetX;\n                boundArea.right -= offsetX;\n                boundArea.top -= offsetY;\n                boundArea.bottom -= offsetY;\n\n                this.gesto.scrollBy(\n                    offsetX,\n                    offsetY,\n                    inputEvent.inputEvent,\n                    // false\n                );\n                this._checkSelected(this.gesto.getCurrentEvent());\n            });\n    }\n    private _select(\n        selectedTargets: ElementType[],\n        rect: Rect,\n        e: OnDragEvent,\n        isStart?: boolean,\n        isDragStartEnd = false,\n    ) {\n        const inputEvent = e.inputEvent;\n        const data = e.data;\n        const result = this.setSelectedTargets(selectedTargets);\n        const { added, removed, prevList, list } = diff(\n            data.startSelectedTargets,\n            selectedTargets,\n        );\n\n        const startResult = {\n            startSelected: prevList,\n            startAdded: added.map(i => list[i]),\n            startRemoved: removed.map(i => prevList[i]),\n        };\n\n\n        if (isStart) {\n            /**\n             * When the select(drag) starts, the selectStart event is called.\n             * @memberof Selecto\n             * @event selectStart\n             * @param {Selecto.OnSelect} - Parameters for the selectStart event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"selectStart\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * }).on(\"selectEnd\", e => {\n             *   e.afterAdded.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.afterRemoved.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"selectStart\", {\n                ...result,\n                ...startResult,\n                rect,\n                inputEvent,\n                data: data.data,\n                isTrusted: e.isTrusted,\n                isDragStartEnd,\n            });\n        }\n        if (result.added.length || result.removed.length) {\n            /**\n             * When the select in real time, the select event is called.\n             * @memberof Selecto\n             * @event select\n             * @param {Selecto.OnSelect} - Parameters for the select event\n             * @example\n             * import Selecto from \"selecto\";\n             *\n             * const selecto = new Selecto({\n             *   container: document.body,\n             *   selectByClick: true,\n             *   selectFromInside: false,\n             * });\n             *\n             * selecto.on(\"select\", e => {\n             *   e.added.forEach(el => {\n             *     el.classList.add(\"selected\");\n             *   });\n             *   e.removed.forEach(el => {\n             *     el.classList.remove(\"selected\");\n             *   });\n             * });\n             */\n            this.emit(\"select\", {\n                ...result,\n                ...startResult,\n                rect,\n                inputEvent,\n                data: data.data,\n                isTrusted: e.isTrusted,\n                isDragStartEnd,\n            });\n        }\n    }\n    private _selectEnd(\n        startSelectedTargets: ElementType[],\n        startPassedTargets: ElementType[],\n        rect: Rect,\n        e: OnDragEvent,\n        isDragStartEnd: boolean = false,\n    ) {\n        const { inputEvent, isDouble, data } = e;\n        const type = inputEvent && inputEvent.type;\n        const isDragStart = type === \"mousedown\" || type === \"touchstart\";\n\n        const { added, removed, prevList, list } = diff(\n            startSelectedTargets,\n            this.selectedTargets\n        );\n        const {\n            added: afterAdded,\n            removed: afterRemoved,\n            prevList: afterPrevList,\n            list: afterList,\n        } = diff(startPassedTargets, this.selectedTargets);\n\n        /**\n         * When the select(dragEnd or click) ends, the selectEnd event is called.\n         * @memberof Selecto\n         * @event selectEnd\n         * @param {Selecto.OnSelectEnd} - Parameters for the selectEnd event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"selectStart\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * }).on(\"selectEnd\", e => {\n         *   e.afterAdded.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.afterRemoved.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"selectEnd\", {\n            startSelected: startSelectedTargets,\n            beforeSelected: startPassedTargets,\n            selected: this.selectedTargets,\n            added: added.map((index) => list[index]),\n            removed: removed.map((index) => prevList[index]),\n            afterAdded: afterAdded.map((index) => afterList[index]),\n            afterRemoved: afterRemoved.map((index) => afterPrevList[index]),\n            isDragStart: isDragStart && isDragStartEnd,\n            isDragStartEnd: isDragStart && isDragStartEnd,\n            isClick: !!e.isClick,\n            isDouble: !!isDouble,\n            rect,\n            inputEvent,\n            data: data.data,\n            isTrusted: e.isTrusted,\n        });\n    }\n    private _onDragStart = (e: OnDragStart<Gesto>, clickedTarget?: Element) => {\n        const { data, clientX, clientY, inputEvent } = e;\n        const {\n            selectFromInside,\n            selectByClick,\n            rootContainer,\n            boundContainer,\n            preventDragFromInside = true,\n            clickBySelectEnd,\n            dragCondition,\n        } = this.options;\n\n        if (dragCondition && !dragCondition(e)) {\n            e.stop();\n            return;\n        }\n        data.data = {};\n        const win = getWindow(this.container);\n        data.innerWidth = win.innerWidth;\n        data.innerHeight = win.innerHeight;\n        this.findSelectableTargets(data);\n        data.startSelectedTargets = this.selectedTargets;\n        data.scaleMatrix = createMatrix();\n        data.containerX = 0;\n        data.containerY = 0;\n\n\n        const container = this.container;\n        let boundArea = {\n            left: -Infinity,\n            top: -Infinity,\n            right: Infinity,\n            bottom: Infinity,\n        };\n        if (rootContainer) {\n            const containerRect = this.container.getBoundingClientRect();\n\n            data.containerX = containerRect.left;\n            data.containerY = containerRect.top;\n            data.scaleMatrix = getDistElementMatrix(this.container, rootContainer);\n        }\n\n        if (boundContainer) {\n            const boundInfo: Required<BoundContainer> =\n                isObject(boundContainer) && \"element\" in boundContainer\n                    ? {\n                        left: true,\n                        top: true,\n                        bottom: true,\n                        right: true,\n                        ...boundContainer,\n                    }\n                    : {\n                        element: boundContainer,\n                        left: true,\n                        top: true,\n                        bottom: true,\n                        right: true,\n                    };\n            const boundElement = boundInfo.element;\n            let rectElement: HTMLElement;\n\n            if (boundElement) {\n                if (isString(boundElement)) {\n                    rectElement = getDocument(container).querySelector(boundElement);\n                } else if (boundElement === true) {\n                    rectElement = this.container;\n                } else {\n                    rectElement = boundElement;\n                }\n                const rect = rectElement.getBoundingClientRect();\n\n                if (boundInfo.left) {\n                    boundArea.left = rect.left;\n                }\n                if (boundInfo.top) {\n                    boundArea.top = rect.top;\n                }\n                if (boundInfo.right) {\n                    boundArea.right = rect.right;\n                }\n                if (boundInfo.bottom) {\n                    boundArea.bottom = rect.bottom;\n                }\n            }\n        }\n\n        data.boundArea = boundArea;\n\n        const hitRect = {\n            left: clientX,\n            top: clientY,\n            right: clientX,\n            bottom: clientY,\n            width: 0,\n            height: 0,\n        };\n        let firstPassedTargets: ElementType[] = [];\n\n        // allow click on select\n        const allowClickBySelectEnd = selectByClick && !clickBySelectEnd;\n        let hasInsideTargets = false;\n\n        if (!selectFromInside || allowClickBySelectEnd) {\n            const pointTarget = this._findElement(\n                clickedTarget || inputEvent.target, // elementFromPoint(clientX, clientY),\n                data.selectableTargets,\n            );\n\n            hasInsideTargets = !!pointTarget;\n            if (allowClickBySelectEnd) {\n                firstPassedTargets = pointTarget ? [pointTarget] : [];\n            }\n        }\n        const isPreventSelect = !selectFromInside && hasInsideTargets;\n\n        // prevent drag from inside when selectByClick is false\n        if (isPreventSelect && !selectByClick) {\n            e.stop();\n            return false;\n        }\n\n        const type = inputEvent.type;\n        const isTrusted = type === \"mousedown\" || type === \"touchstart\";\n        /**\n         * When the drag starts (triggers on mousedown or touchstart), the dragStart event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event dragStart\n         * @param {OnDragStart} - Parameters for the dragStart event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"dragStart\", e => {\n         *   if (e.inputEvent.target.tagName === \"SPAN\") {\n         *     e.stop();\n         *   }\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        const result =\n            !(e).isClick && isTrusted\n                ? this.emit(\"dragStart\", { ...e, data: data.data })\n                : true;\n\n        if (!result) {\n            e.stop();\n            return false;\n        }\n\n        if (this.continueSelect) {\n            firstPassedTargets = passTargets(\n                this.selectedTargets,\n                firstPassedTargets,\n                this.continueSelectWithoutDeselect,\n            );\n            data.startPassedTargets = this.selectedTargets;\n        } else {\n            data.startPassedTargets = [];\n        }\n\n        this._select(\n            firstPassedTargets,\n            hitRect,\n            e,\n            true,\n            isPreventSelect && selectByClick && !clickBySelectEnd && preventDragFromInside,\n        );\n        data.startX = clientX;\n        data.startY = clientY;\n        data.selectFlag = false;\n        data.preventDragFromInside = false;\n\n        if (inputEvent.target) {\n            const offsetPos = calculateMatrixDist(data.scaleMatrix, [\n                clientX - data.containerX,\n                clientY - data.containerY,\n            ]);\n            this.target.style.cssText += `position: ${rootContainer ? \"absolute\" : \"fixed\"};`\n                + `left:0px;top:0px;`\n                + `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px)`;\n        }\n\n        if (isPreventSelect && selectByClick && !clickBySelectEnd) {\n            inputEvent.preventDefault();\n\n            // prevent drag from inside when selectByClick is true and force call `selectEnd`\n            if (preventDragFromInside) {\n                this._selectEnd(\n                    data.startSelectedTargets,\n                    data.startPassedTargets,\n                    hitRect,\n                    e,\n                    true,\n                );\n                data.preventDragFromInside = true;\n            }\n        } else {\n            data.selectFlag = true;\n            // why?\n            // if (type === \"touchstart\") {\n            //     inputEvent.preventDefault();\n            // }\n            const { scrollOptions, innerScrollOptions } = this.options;\n\n            let isInnerScroll = false\n\n            if (innerScrollOptions) {\n                const inputEvent = e.inputEvent;\n                const target = inputEvent.target;\n\n                let innerScrollElement: HTMLElement | null = null;\n                let parentElement = target;\n\n                while (parentElement && parentElement !== getDocument(container).body) {\n\n                    const overflow = getComputedStyle(parentElement).overflow !== \"visible\";\n\n                    if (overflow) {\n                        innerScrollElement = parentElement;\n                        break;\n                    }\n                    parentElement = parentElement.parentElement;\n                }\n                if (innerScrollElement) {\n                    data.innerScrollOptions = {\n                        container: innerScrollElement,\n                        checkScrollEvent: true,\n                        ...(innerScrollOptions === true ? {} : innerScrollOptions),\n                    };\n                    this.dragScroll.dragStart(e, data.innerScrollOptions);\n\n                    isInnerScroll = true;\n                }\n            }\n            if (!isInnerScroll && scrollOptions && scrollOptions.container) {\n                this.dragScroll.dragStart(e, scrollOptions);\n            }\n\n            if (isPreventSelect && selectByClick && clickBySelectEnd) {\n                data.selectFlag = false;\n                e.preventDrag();\n            }\n        }\n        return true;\n    };\n    private _checkSelected(e: any, rect = getRect(e, this.options.ratio)) {\n        const { data } = e;\n        const { top, left, width, height } = rect;\n        const selectFlag = data.selectFlag;\n        const {\n            containerX,\n            containerY,\n            scaleMatrix,\n        } = data;\n        const offsetPos = calculateMatrixDist(scaleMatrix, [\n            left - containerX,\n            top - containerY,\n        ]);\n        const offsetSize = calculateMatrixDist(scaleMatrix, [\n            width,\n            height,\n        ]);\n        let selectedTargets: ElementType[] = [];\n        if (selectFlag) {\n            this.target.style.cssText +=\n                `display: block;` +\n                `left:0px;top:0px;` +\n                `transform: translate(${offsetPos[0]}px, ${offsetPos[1]}px);` +\n                `width:${offsetSize[0]}px;height:${offsetSize[1]}px;`;\n\n            const passedTargets = this.hitTest(\n                rect,\n                data,\n                true,\n                e,\n            );\n            selectedTargets = passTargets(\n                data.startPassedTargets,\n                passedTargets,\n                this.continueSelect && this.continueSelectWithoutDeselect,\n            );\n        }\n        /**\n         * When the drag, the drag event is called.\n         * Call the stop () function if you have a specific element or don't want to raise a select\n         * @memberof Selecto\n         * @event drag\n         * @param {OnDrag} - Parameters for the drag event\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   selectByClick: true,\n         *   selectFromInside: false,\n         * });\n         *\n         * selecto.on(\"drag\", e => {\n         *   e.stop();\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        const result = this.emit(\"drag\", {\n            ...e,\n            data: data.data,\n            isSelect: selectFlag,\n            rect,\n        });\n        if (result === false) {\n            this.target.style.cssText += \"display: none;\";\n            e.stop();\n            return;\n        }\n\n        if (selectFlag) {\n            this._select(selectedTargets, rect, e);\n        }\n    }\n    private _onDrag = (e: OnDrag) => {\n        if (e.data.selectFlag) {\n            const scrollOptions = this.scrollOptions;\n            const innerScrollOptions = e.data.innerScrollOptions;\n            const hasScrollOptions = innerScrollOptions || scrollOptions?.container;\n\n            // If it is a scrolling position, pass drag\n            if (hasScrollOptions && !e.isScroll && this.dragScroll.drag(e, innerScrollOptions || scrollOptions)) {\n                return;\n            }\n        }\n        this._checkSelected(e);\n    };\n    private _onDragEnd = (e: OnDragEvent) => {\n        const { data, inputEvent } = e;\n        const rect = getRect(e, this.options.ratio);\n        const selectFlag = data.selectFlag;\n        const container = this.container;\n\n        /**\n         * When the drag ends (triggers on mouseup or touchend after drag), the dragEnd event is called.\n         * @memberof Selecto\n         * @event dragEnd\n         * @param {OnDragEnd} - Parameters for the dragEnd event\n         */\n        if (inputEvent) {\n            this.emit(\"dragEnd\", {\n                isDouble: !!e.isDouble,\n                isClick: !!e.isClick,\n                isDrag: false,\n                isSelect: selectFlag,\n                ...e,\n                data: data.data,\n                rect,\n            });\n        }\n        this.target.style.cssText += \"display: none;\";\n\n        if (selectFlag) {\n            data.selectFlag = false;\n            this.dragScroll.dragEnd();\n        } else if (this.selectByClick && this.clickBySelectEnd) {\n            // only clickBySelectEnd\n            const pointTarget = this._findElement(\n                inputEvent?.target || elementFromPoint(container, e.clientX, e.clientY),\n                data.selectableTargets,\n            );\n            this._select(pointTarget ? [pointTarget] : [], rect, e);\n        }\n        if (!data.preventDragFromInside) {\n            this._selectEnd(\n                data.startSelectedTargets,\n                data.startPassedTargets,\n                rect,\n                e\n            );\n        }\n    };\n    private _sameCombiKey(e: any, keys: string | string[] | string[][], isKeyup?: boolean) {\n        if (!keys) {\n            return false;\n        }\n        const combi = getCombi(e.inputEvent, e.key);\n        const nextKeys = [].concat(keys);\n        const toggleKeys = isArray(nextKeys[0]) ? nextKeys : [nextKeys];\n\n        if (isKeyup) {\n            const singleKey = e.key;\n\n            return toggleKeys.some((keys) =>\n                keys.some((key: string) => key === singleKey)\n            );\n        }\n        return toggleKeys.some((keys) =>\n            keys.every((key: string) => combi.indexOf(key) > -1)\n        );\n    }\n    private _onKeyDown = (e: KeyControllerEvent) => {\n        const options = this.options;\n        let isKeyDown = false;\n\n        if (!this._keydownContinueSelect) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelect);\n\n            this._keydownContinueSelect = result;\n            isKeyDown ||= result;\n        }\n        if (!this._keydownContinueSelectWithoutDeselection) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect);\n\n            this._keydownContinueSelectWithoutDeselection = result;\n            isKeyDown ||= result;\n        }\n        if (!isKeyDown) {\n            return;\n        }\n        /**\n         * When you keydown the key you specified in toggleContinueSelect, the keydown event is called.\n         * @memberof Selecto\n         * @event keydown\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   toggleContinueSelect: \"shift\";\n         *   keyContainer: window,\n         * });\n         *\n         * selecto.on(\"keydown\", () => {\n         *   document.querySelector(\".button\").classList.add(\"selected\");\n         * }).on(\"keyup\", () => {\n         *   document.querySelector(\".button\").classList.remove(\"selected\");\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"keydown\", {\n            keydownContinueSelect: this._keydownContinueSelect,\n            keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n        });\n    };\n    private _onKeyUp = (e: KeyControllerEvent) => {\n        const options = this.options;\n        let isKeyUp = false;\n\n        if (this._keydownContinueSelect) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelect, true);\n            this._keydownContinueSelect = !result;\n\n            isKeyUp ||= result;\n        }\n        if (this._keydownContinueSelectWithoutDeselection) {\n            const result = this._sameCombiKey(e, options.toggleContinueSelectWithoutDeselect, true);\n            this._keydownContinueSelectWithoutDeselection = !result;\n\n            isKeyUp ||= result;\n        }\n        if (!isKeyUp) {\n            return;\n        }\n\n        /**\n         * When you keyup the key you specified in toggleContinueSelect, the keyup event is called.\n         * @memberof Selecto\n         * @event keyup\n         * @example\n         * import Selecto from \"selecto\";\n         *\n         * const selecto = new Selecto({\n         *   container: document.body,\n         *   toggleContinueSelect: \"shift\";\n         *   keyContainer: window,\n         * });\n         *\n         * selecto.on(\"keydown\", () => {\n         *   document.querySelector(\".button\").classList.add(\"selected\");\n         * }).on(\"keyup\", () => {\n         *   document.querySelector(\".button\").classList.remove(\"selected\");\n         * }).on(\"select\", e => {\n         *   e.added.forEach(el => {\n         *     el.classList.add(\"selected\");\n         *   });\n         *   e.removed.forEach(el => {\n         *     el.classList.remove(\"selected\");\n         *   });\n         * });\n         */\n        this.emit(\"keyup\", {\n            keydownContinueSelect: this._keydownContinueSelect,\n            keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n        });\n    };\n    private _onBlur = () => {\n        if (this._keydownContinueSelect || this._keydownContinueSelectWithoutDeselection) {\n            this._keydownContinueSelect = false;\n            this._keydownContinueSelectWithoutDeselection = false;\n            this.emit(\"keyup\", {\n                keydownContinueSelect: this._keydownContinueSelect,\n                keydownContinueSelectWithoutDeselection: this._keydownContinueSelectWithoutDeselection,\n            });\n        }\n    };\n    private _onDocumentSelectStart = (e: any) => {\n        const doc = getDocument(this.container);\n\n        if (!this.gesto.isFlag()) {\n            return;\n        }\n        let dragContainer = this.dragContainer;\n\n        if (dragContainer === getWindow(this.container)) {\n            dragContainer = doc.documentElement;\n        }\n        const containers = isNode(dragContainer)\n            ? [dragContainer]\n            : ([].slice.call(dragContainer) as Element[]);\n        const target = e.target;\n\n        containers.some((container) => {\n            if (container === target || container.contains(target)) {\n                e.preventDefault();\n                return true;\n            }\n        });\n    };\n    private _findElement(clickedTarget: ElementType, selectableTargets: Element[]) {\n        let pointTarget = clickedTarget;\n\n        while (pointTarget) {\n            if (selectableTargets.indexOf(pointTarget) > -1) {\n                break;\n            }\n            pointTarget = pointTarget.parentElement;\n        }\n        return pointTarget;\n    }\n    private _refreshGroups(data: IObject<any>) {\n        const innerWidth = data.innerWidth;\n        const innerHeight = data.innerHeight;\n        const selectablePoints: number[][][] = data.selectablePoints;\n\n        if (this.options.checkOverflow) {\n            const innerScrollContainer = this.gesto.getEventData().innerScrollOptions?.container;\n            const parentMap: Map<Element, InnerParentInfo> = data.selectableInnerScrollParentMap;\n            const innerScrollPathsList: Element[][] = data.selectableInnerScrollPathsList;\n\n            data.selectableInners = innerScrollPathsList.map((innerScrollPaths, i) => {\n                let isAlwaysTrue = false;\n                return innerScrollPaths.every(target => {\n                    if (isAlwaysTrue) {\n                        return true;\n                    }\n                    if (target === innerScrollContainer) {\n                        isAlwaysTrue = true;\n                        return true;\n                    }\n\n                    const rect = parentMap.get(target);\n\n                    if (rect) {\n                        const points1 = selectablePoints[i];\n                        const points2 = rect.points;\n                        const overlapPoints = getOverlapPoints(points1, points2);\n\n                        if (!overlapPoints.length) {\n                            return false;\n                        }\n                    }\n                    return true;\n                });\n            });\n        }\n        if (!innerWidth || !innerHeight) {\n            data.innerGroups = null;\n        } else {\n            const selectablePoints: number[][][] = data.selectablePoints;\n\n            const groups: Record<string | number, Record<string | number, number[]>> = {};\n\n            selectablePoints.forEach((points, i) => {\n                let minX = Infinity;\n                let maxX = -Infinity;\n                let minY = Infinity;\n                let maxY = -Infinity;\n\n                points.forEach(pos => {\n                    const x = Math.floor(pos[0] / innerWidth);\n                    const y = Math.floor(pos[1] / innerHeight);\n\n                    minX = Math.min(x, minX);\n                    maxX = Math.max(x, maxX);\n                    minY = Math.min(y, minY);\n                    maxY = Math.max(y, maxY);\n                });\n\n                for (let x = minX; x <= maxX; ++x) {\n                    for (let y = minY; y <= maxY; ++y) {\n                        groups[x] = groups[x] || {};\n                        groups[x][y] = groups[x][y] || [];\n\n                        groups[x][y].push(i);\n                    }\n                }\n            });\n\n            data.innerGroups = groups;\n        }\n    }\n}\n\ninterface Selecto extends SelectoProperties { }\n\nexport default Selecto;\n","import SelectoManager from \"./SelectoManager\";\n\nclass Selecto extends SelectoManager {\n\n}\nexport default Selecto;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}